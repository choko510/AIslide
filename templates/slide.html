<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content">
    <title>Web Slide Maker - Modern (Enhanced)</title>
    <link rel="stylesheet" href="https://site-assets.fontawesome.com/releases/v6.7.2/css/all.css">
    <style>
        /* --- モダンデザイン & 基本スタイル --- */
        :root {
            --primary-color: #007bff;
            --primary-color-hover: #0056b3;
            --bg-light: #f8f9fa;
            --bg-white: #ffffff;
            --border-color: #dee2e6;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --danger-color: #dc3545;
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.08);
            --border-radius: 8px;
            --transition: all 0.2s ease-in-out;
            --guide-color: #ff4757;
            /* スマートガイドの色 */
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Noto Sans JP', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif;
            background-color: var(--bg-light);
            color: var(--text-primary);
            overflow: hidden;
            height: 100dvh;
            user-select: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .slide-element.text {
            font-family: 'Noto Sans JP', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif;
        }

        #app-container {
            display: flex;
            height: 100dvh;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- ツールバー --- */
        #toolbar {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            background-color: var(--bg-white);
            border-bottom: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            z-index: 100;
            flex-shrink: 0;
        }

        #toolbar button {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border: 1px solid transparent;
            background-color: transparent;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
            font-size: 14px;
            color: var(--text-secondary);
        }

        #toolbar button:hover:not(:disabled) {
            background-color: var(--bg-light);
            color: var(--text-primary);
        }

        #toolbar button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }

        #toolbar button svg {
            width: 16px;
            height: 16px;
            stroke-width: 2;
            fill: none;
            stroke: currentColor;
        }

        #toolbar .separator {
            width: 1px;
            height: 24px;
            background-color: var(--border-color);
            margin: 0 12px;
        }

        #export-menu {
            border-radius: var(--border-radius);
            padding: 4px;
        }

        #export-menu div {
            border-radius: 4px;
        }

        #export-menu div:hover {
            background-color: var(--bg-light);
        }

        /* --- メインレイアウト (New) --- */
        #app-body {
            /* Replaces main */
            display: flex;
            flex-grow: 1;
            overflow: hidden !important;
        }

        /* --- 左サイドバー (New) --- */
        #left-sidebar {
            background-color: var(--bg-white);
            border-right: 1px solid var(--border-color);
            display: flex;
            /* flex-direction is now row */
            transition: width 0.2s ease;
            flex-shrink: 0;
            width: 340px;
            /* Default total width */
        }

        #sidebar-tabs {
            display: flex;
            flex-direction: column;
            /* Vertical tabs */
            padding: 8px;
            gap: 8px;
            border-right: 1px solid var(--border-color);
            background-color: var(--bg-light);
            /* Slightly different bg for tabs */
            flex-shrink: 0;
        }

        .sidebar-tab-button {
            width: 100%;
            /* Take full width of the tab container */
            height: auto;
            padding: 8px 4px;
            background: none;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            /* Icon and text vertically aligned */
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            transition: var(--transition);
            gap: 4px;
            /* Space between icon and text */
        }

        .sidebar-tab-button i {
            font-size: 18px;
            /* Icon size */
            margin-bottom: 2px;
        }

        .sidebar-tab-button span {
            font-size: 10px;
            /* Text label size */
            line-height: 1.2;
            display: block;
        }

        .sidebar-tab-button:hover {
            background-color: #e9ecef;
            /* Hover effect */
            color: var(--text-primary);
        }

        .sidebar-tab-button.active {
            background-color: var(--primary-color);
            color: white;
        }

        #sidebar-content {
            overflow-y: auto;
            flex-grow: 1;
            padding: 16px;
            /* Padding for content inside tabs */
        }

        .sidebar-tab-content {
            display: none;
            /* Padding is now on sidebar-content */
        }

        .sidebar-tab-content.active {
            display: block;
        }

        /* スライド一覧のスタイル (旧 #left-pane の一部を適用) */
        #slide-list {
            list-style: none;
            padding: 0;
            /* Adjusted from 16px to 0 as tab content has padding */
            /* overflow-y: auto; /* sidebar-content handles scrolling */
            /* flex-grow: 1; */
        }

        .sidebar-add-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            /* Center content if text is short */
            gap: 8px;
            padding: 10px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-white);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
            font-size: 13px;
            color: var(--text-primary);
            text-align: left;
        }

        .sidebar-add-btn:hover {
            background-color: var(--bg-light);
            border-color: var(--primary-color-hover);
        }

        .sidebar-add-btn i {
            color: var(--primary-color);
        }


        /* #left-pane-header is now inside a tab, style accordingly */
        #left-pane-header {
            /* This ID is still used for the "スライド一覧" title */
            padding-bottom: 10px;
            font-size: 16px;
            /* Keep font size */
            font-weight: 600;
            /* Keep font weight */
            /* border-bottom: 1px solid var(--border-color); Removed, as tabs have border */
        }


        .slide-thumbnail {
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: var(--border-radius);
            padding: 4px;
            margin-right: 12px;
            margin-bottom: 0;
            position: relative;
            transition: var(--transition);
            flex-shrink: 0;
            width: 160px;
        }

        .slide-thumbnail:hover {
            background-color: var(--bg-light);
        }

        .slide-thumbnail.active {
            border-color: var(--primary-color);
            background-color: #e6f2ff;
        }

        .slide-thumbnail.dragging {
            opacity: 0.5;
        }

        .slide-thumbnail.drag-over {
            border-style: dashed;
        }

        .slide-thumbnail-wrapper {
            width: 100%;
            aspect-ratio: 16 / 9;
            background-color: var(--bg-white);
            border: 1px solid var(--border-color);
            position: relative;
            overflow: hidden;
            border-radius: 4px;
        }

        .slide-thumbnail-content {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: top left;
            background-color: white;
        }

        .thumbnail-index {
            position: absolute;
            top: 0;
            left: 0;
            background: var(--text-secondary);
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            text-align: center;
            line-height: 22px;
            font-size: 12px;
            font-weight: 500;
            z-index: 1;
        }

        .slide-thumbnail.active .thumbnail-index {
            background: var(--primary-color);
        }

        /* --- 中央キャンバスエリア (New, 旧 #main-pane) --- */
        #main-canvas-area {
            /* Replaces #main-pane */
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 24px;
            min-width: 0;
            min-height: 0;
            background-color: var(--bg-light);
            /* Added for contrast if needed */
        }

        #slide-wrapper {
            position: relative;
            max-width: 90vw;
            width: 100%;
            aspect-ratio: 16 / 9;
            background: transparent;
            border-radius: 0;
            box-shadow: none;
            overflow: visible;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #slide-canvas {
            width: 1280px;
            height: 720px;
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 16 / 9;
            position: relative;
            overflow: hidden !important;
            background: var(--bg-white);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-md);
        }

        /* --- スライド要素 --- */
        .slide-element {
            position: absolute;
            cursor: move;
        }

        .slide-element.text {
            padding: 5px;
            line-height: 1.3;
            word-wrap: break-word;
            max-width: 100%;
        }

        .slide-element img {
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .slide-element[contenteditable="false"] {
            caret-color: transparent;
        }

        .slide-element[contenteditable="true"] {
            cursor: text;
        }

        .slide-element.icon {
            width: auto;
            height: auto;
        }

        .slide-element.selected {
            outline: 2px solid var(--primary-color);
            z-index: 9999 !important;
        }

        /* 複数選択時のバウンディングボックス */
        .selection-bounding-box {
            position: absolute;
            border: 1px dashed var(--primary-color);
            pointer-events: none;
            z-index: 9998;
        }

        /* 範囲選択用ラバーバンド */
        .selection-box {
            position: absolute;
            border: 2px solid #3399ff;
            background: rgba(51, 153, 255, 0.15);
            pointer-events: none;
            z-index: 10001;
            border-radius: 4px;
        }

        /* スマートガイドライン */
        .guide-line {
            position: absolute;
            background-color: var(--guide-color);
            z-index: 10000;
            pointer-events: none;
        }

        .guide-line.horizontal {
            width: 100%;
            height: 1px;
            left: 0;
        }

        .guide-line.vertical {
            height: 100%;
            width: 1px;
            top: 0;
        }

        /* --- リサイズハンドル --- */
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--bg-white);
            border: 2px solid var(--primary-color);
            border-radius: 2px;
            z-index: 10000;
            transform: translate(-50%, -50%);
        }

        .resize-handle.nw {
            top: 0;
            left: 0;
            cursor: nwse-resize;
        }

        .resize-handle.n {
            top: 0;
            left: 50%;
            cursor: ns-resize;
        }

        .resize-handle.ne {
            top: 0;
            right: 0;
            left: auto;
            cursor: nesw-resize;
        }

        .resize-handle.w {
            top: 50%;
            left: 0;
            cursor: ew-resize;
        }

        .resize-handle.e {
            top: 50%;
            right: 0;
            left: auto;
            cursor: ew-resize;
        }

        .resize-handle.sw {
            bottom: 0;
            top: auto;
            left: 0;
            cursor: nesw-resize;
        }

        .resize-handle.s {
            bottom: 0;
            top: auto;
            left: 50%;
            cursor: ns-resize;
        }

        .resize-handle.se {
            bottom: 0;
            top: auto;
            right: 0;
            left: auto;
            cursor: nwse-resize;
        }

        /* --- インスペクター (Now inside left-sidebar) --- */
        /* #right-pane styles are largely deprecated or moved to #left-sidebar */

        #inspector h3 {
            margin-top: 0;
            margin-bottom: 24px;
            /* Keep spacing for titles within inspector */
            font-size: 16px;
            font-weight: 600;
        }

        .inspector-group {
            margin-bottom: 20px;
        }

        .inspector-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .inspector-group input[type="text"],
        .inspector-group input[type="number"],
        .inspector-group input[type="color"],
        .inspector-group select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 14px;
            transition: var(--transition);
        }

        .inspector-group input:focus,
        .inspector-group select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

        .inspector-group input[type="color"] {
            padding: 4px;
            height: 38px;
        }

        .pos-size-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        #no-selection-message {
            /* Still relevant, but now inside a tab */
            color: var(--text-secondary);
            text-align: center;
            margin-top: 50px;
            /* Or adjust based on tab layout */
            padding: 20px;
        }

        #delete-element-btn {
            width: 100%;
            padding: 8px 16px;
            border-radius: var(--border-radius);
            cursor: pointer;
            background-color: var(--danger-color);
            color: white;
            border: none;
            font-weight: 500;
            transition: var(--transition);
        }

        #delete-element-btn:hover {
            background-color: #c82333;
        }

        /* --- プレゼンテーションモード --- */
        body.presentation-mode {
            background-color: #000;
        }

        .presentation-mode #app-container {
            display: none;
        }

        #presentation-view {
            display: none;
            width: 100vw;
            height: 100vh;
            background-color: #000;
            justify-content: center;
            align-items: center;
        }

        .presentation-mode #presentation-view {
            display: flex;
        }

        #presentation-slide-container {
            position: relative;
            background-color: white;
            overflow: hidden;
        }

        /* --- コンテキストメニュー --- */
        #slide-context-menu,
        #element-context-menu {
            border-radius: var(--border-radius);
            padding: 4px;
            min-width: 140px !important;
        }

        #slide-context-menu div,
        #element-context-menu div {
            border-radius: 4px;
        }

        #slide-context-menu div:hover,
        #element-context-menu div:hover {
            background-color: var(--bg-light);
        }

        /* アラインメントボタングループ */
        .btn-group {
            display: flex;
            gap: 4px;
        }

        .btn-group button {
            padding: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-group button svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
            stroke-width: 0.5;
            fill: currentColor;
        }

        /* 旧タブのスタイル ( .right-pane-tabs, .tab-button, .tab-content ) は削除または .sidebar-tab-button / .sidebar-tab-content に置き換え */
        /*
        .right-pane-tabs { ... }
        .tab-button { ... }
        .tab-button.active { ... }
        .tab-content { ... }
        .tab-content.active { ... }
        */

        .user-msg {
            color: #007bff;
            margin-bottom: 10px;
        }

        .ai-msg {
            background-color: #f8f9fa;
            border-left: 3px solid #28a745;
            padding: 10px;
            margin-bottom: 15px;
        }

        .ai-msg pre {
            background-color: #e9ecef;
            padding: 10px;
            overflow-x: auto;
            margin: 10px 0;
        }

        .execute-btn {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
        }

        .success-msg {
            color: #28a745;
            font-weight: bold;
            margin-top: 10px;
        }

        .error-msg {
            color: #dc3545;
            font-weight: bold;
            margin-top: 10px;
        }

        .ai-instruction {
            font-size: 12px;
            color: #6c757d;
            margin: 5px 0;
        }

        /* --- レスポンシブデザイン --- */
        @media (min-width: 1400px) {
            #left-sidebar {
                width: 360px;
            }
        }

        @media (max-width: 1024px) {

            /* Adjust for new layout if necessary */
            #left-sidebar {
                width: 240px;
                /* Slightly narrower sidebar for smaller screens */
            }
        }

        @media (max-width: 768px) {
            body {
                overflow: auto;
                height: auto;
            }

            #app-container {
                height: auto;
                min-height: 100vh;
            }

            #app-body {
                /* main was flex-direction: column */
                flex-direction: column;
                height: auto;
                flex-grow: 1;
                overflow: hidden;
            }

            #left-sidebar {
                /* Was #left-pane and #right-pane */
                width: 100%;
                border: none;
                box-shadow: none;
                order: 2;
                /* Sidebar content (like slides, elements) can come after canvas */
                border-top: 1px solid var(--border-color);
                /* height: auto; /* Let content define height */
                /* padding: 0; /* sidebar-content handles padding */
            }

            #sidebar-tabs {
                /* Potentially make tabs scrollable horizontally if too many */
                overflow-x: auto;
            }

            .sidebar-tab-button {
                font-size: 12px;
                /* Smaller tabs on mobile */
                padding: 10px 6px;
            }


            /* #left-pane-header was display:none, but now it's part of a tab. */
            /* It should be visible if its tab is active. */

            #slide-list {
                /* Copied from old #slide-list for mobile */
                display: flex;
                flex-direction: row;
                overflow-x: auto;
                padding: 12px;
                /* Keep padding for horizontal scroll items */
                align-items: center;
            }

            .slide-thumbnail {
                /* Copied from old .slide-thumbnail for mobile */
                flex-shrink: 0;
                width: 120px;
                margin-right: 12px;
                margin-bottom: 0;
            }

            #main-canvas-area {
                /* Was #main-pane */
                padding: 12px;
                order: 1;
                /* Canvas comes first on mobile */
            }

            #slide-wrapper {
                max-width: 100vw;
                /* Full width on mobile */
                width: 100%;
                /* Ensure it takes full width */
                /* aspect-ratio: 16 / 9; /* This should be fine */
            }

            #slide-canvas {
                /* width: 1280px; These are base, scaling should handle it */
                /* height: 720px; */
                max-width: 100%;
                max-height: 100%;
                /* aspect-ratio: 16 / 9; */
            }

            /* #right-pane specific styles are removed or adapted */

            #toolbar {
                flex-wrap: wrap;
                padding: 8px;
            }

            #toolbar button {
                margin-bottom: 4px;
            }

            #toolbar button span {
                /* Hides text on mobile */
                display: none;
            }

            #toolbar .separator {
                margin: 0 8px;
            }
        }

        /* Targeting landscape on smaller devices */
        @media (max-width: 768px) and (orientation: landscape) {
            #toolbar {
                padding: 4px 8px;
                /* Reduce padding */
                flex-wrap: nowrap;
                /* Try to keep toolbar items in one line if possible */
                overflow-x: auto;
                /* Allow horizontal scroll if they don't fit */
            }

            #toolbar button {
                padding: 4px 6px;
                /* Smaller buttons */
                gap: 4px;
            }

            #toolbar button i {
                font-size: 14px;
                /* Slightly smaller icons */
            }

            #toolbar .separator {
                margin: 0 4px;
                height: 20px;
            }

            #left-sidebar {
                width: 200px;
                /* Narrower sidebar in landscape mobile */
            }

            .sidebar-tab-button {
                font-size: 11px;
                /* Even smaller tab text */
                padding: 8px 4px;
            }

            #slide-list {
                /* Ensure slide list items are small enough */
                padding: 8px;
            }

            .slide-thumbnail {
                width: 100px;
                margin-right: 8px;
            }
        }

        #sidebar-resize-handle:hover {
            background: rgba(0, 123, 255, 0.08);
        }

        /* Toggle Switch for Autonomous Mode */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            /* Smaller */
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            /* Smaller */
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--primary-color);
        }

        input:checked+.slider:before {
            transform: translateX(20px);
            /* Adjusted */
        }
    </style>
    <!-- Google Fonts: Noto Sans JP を例として追加 -->
    <link
        href="https://fonts.googleapis.com/css2?family=Kaisei+Opti&family=Lato&family=M+PLUS+Rounded+1c:wght@400;700&family=Montserrat:wght@400;700&family=Noto+Sans+JP:wght@400;700&family=Playfair+Display&family=Poppins&family=Roboto:wght@400;700&family=Sawarabi+Mincho&family=Shippori+Mincho&family=Yuji+Syuku&display=swap"
        rel="stylesheet">
</head>

<body>
    <div id="app-container">
        <div id="toolbar">
            <button id="add-slide-btn" title="スライド追加"><i class="fas fa-plus"></i><span>スライド追加</span></button>
            <button id="delete-slide-btn" title="スライド削除"><i class="fas fa-trash-alt"></i><span>スライド削除</span></button>
            <div class="separator"></div>
            <!-- Element add buttons moved to sidebar -->
            <div class="separator"></div>
            <!-- アラインメントボタングループ -->
            <div class="btn-group">
                <button id="align-left-btn" title="左揃え"><i class="fas fa-align-left"></i></button>
                <button id="align-center-h-btn" title="水平中央揃え"><i class="fas fa-align-center"></i></button>
                <button id="align-right-btn" title="右揃え"><i class="fas fa-align-right"></i></button>
                <button id="align-top-btn" title="上揃え"><i class="fas fa-align-top"></i></button>
                <button id="align-center-v-btn" title="垂直中央揃え"><i class="fas fa-arrows-alt-v"></i></button>
                <button id="align-bottom-btn" title="下揃え"><i class="fas fa-align-bottom"></i></button>
                <button id="distribute-h-btn" title="水平方向へ等間隔に配置"><i class="fas fa-grip-lines"></i></button>
                <button id="distribute-v-btn" title="垂直方向へ等間隔に配置"><i class="fas fa-grip-lines-vertical"></i></button>
            </div>
            <div class="separator"></div>
            <button id="save-btn" title="保存"><i class="fas fa-save"></i><span>保存</span></button>
            <button id="present-btn" title="プレゼンテーション開始"><i class="fas fa-play"></i><span>開始</span></button>
            <button id="export-btn" title="エクスポート"><i class="fas fa-download"></i><span>エクスポート</span></button>
            <div id="export-menu"
                style="display:none;position:absolute;z-index:10000;background:#fff;border:1px solid var(--border-color);box-shadow:var(--shadow-md);min-width:160px;">
            </div>
        </div>

        <div id="app-body" style="display: flex; flex-direction: column; flex-grow: 1; overflow: hidden;">
            <div id="center-content" style="display: flex; flex-grow: 1; overflow: hidden !important;">
                <aside id="left-sidebar" style="position: relative;">
                    <div id="sidebar-resize-handle"
                        style="position: absolute; top: 0; right: 0; width: 6px; height: 100%; cursor: ew-resize; z-index: 10; background: transparent;">
                    </div>
                    <div id="sidebar-tabs">
                        <button class="sidebar-tab-button active" data-tab="elements">
                            <i class="fas fa-shapes"></i>
                            <span>素材</span>
                        </button>
                        <button class="sidebar-tab-button" data-tab="icons">
                            <i class="fas fa-icons"></i>
                            <span>アイコン</span>
                        </button>
                        <button class="sidebar-tab-button" data-tab="inspector">
                            <i class="fas fa-sliders-h"></i>
                            <span>設定</span>
                        </button>
                        <button class="sidebar-tab-button" data-tab="page-settings">
                            <i class="fas fa-file-code"></i>
                            <span>ページCSS</span>
                        </button>
                        <button class="sidebar-tab-button" data-tab="chat">
                            <i class="fas fa-robot"></i>
                            <span>AI</span>
                        </button>
                    </div>
                    <div id="sidebar-content">
                        <div class="sidebar-tab-content active" data-tab-content="elements">
                            <div id="element-add-buttons-container"
                                style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <button id="add-text-btn" class="sidebar-add-btn"><i
                                        class="fas fa-font fa-fw"></i><span>テキスト</span></button>
                                <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
                                <button id="add-image-btn" class="sidebar-add-btn"><i
                                        class="fas fa-image fa-fw"></i><span>画像</span></button>
                                <button id="add-video-btn" class="sidebar-add-btn"><i
                                        class="fas fa-video fa-fw"></i><span>動画</span></button>
                                <button id="add-table-btn" class="sidebar-add-btn"><i
                                        class="fas fa-table fa-fw"></i><span>表</span></button>
                                <button id="add-chart-btn" class="sidebar-add-btn"><i
                                        class="fas fa-chart-bar fa-fw"></i><span>グラフ</span></button>
                                <button id="add-iframe-btn" class="sidebar-add-btn"><i
                                        class="fas fa-code fa-fw"></i><span>埋め込み</span></button>
                                <button id="add-qr-btn" class="sidebar-add-btn"><i
                                        class="fas fa-qrcode fa-fw"></i><span>QRコード</span></button>
                            </div>
                        </div>
                        <div class="sidebar-tab-content" data-tab-content="icons">
                            <div style="margin-bottom: 10px; display: flex; gap: 8px;">
                                <button id="fa-toggle-btn" class="sidebar-add-btn active" style="flex-grow: 1;"><i
                                        class="fa-brands fa-font-awesome"></i><span>Font Awesome</span></button>
                                <button id="mi-toggle-btn" class="sidebar-add-btn" style="flex-grow: 1;"><i
                                        class="material-icons">star</i><span>Material Icons</span></button>
                            </div>

                            <!-- Font Awesome Section -->
                            <div id="font-awesome-section">
                                <div id="fa-icon-search-toolbar" style="margin-bottom: 10px;">
                                    <input type="text" id="fa-icon-search-input" placeholder="Font Awesomeアイコン検索..."
                                        style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: var(--border-radius);">
                                </div>
                                <div style="margin-bottom: 10px;">
                                    <label
                                        style="font-size:12px;color:var(--text-secondary);margin-right:6px;">スタイル</label>
                                    <select id="fa-style-select" style="padding:4px 8px;border-radius:6px;">
                                        <option value="fas">Solid</option>
                                        <option value="far">Regular</option>
                                        <option value="fal">Light</option>
                                        <option value="fat">Thin</option>
                                    </select>
                                </div>
                                <div id="fa-icon-category-filter"
                                    style="margin-bottom: 10px; display: flex; flex-wrap: wrap; gap: 6px;">
                                    <!-- Font Awesome カテゴリーボタンはJSで動的に生成されます -->
                                </div>
                                <div id="fa-icon-list-container"
                                    style="display: flex; flex-wrap: wrap; gap: 10px; max-height: 400px; overflow-y: auto;">
                                    <!-- Font Awesome アイコンはここにJavaScriptで描画されます -->
                                </div>
                            </div>

                            <!-- Material Icons Section -->
                            <div id="material-icons-section" style="display: none;">
                                <div id="mi-icon-search-toolbar" style="margin-bottom: 10px;">
                                    <input type="text" id="mi-icon-search-input" placeholder="Material Icons検索..."
                                        style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: var(--border-radius);">
                                </div>
                                <div style="margin-bottom: 10px;">
                                    <label
                                        style="font-size:12px;color:var(--text-secondary);margin-right:6px;">スタイル</label>
                                    <select id="mi-style-select" style="padding:4px 8px;border-radius:6px;">
                                        <option value="material-icons">Filled</option>
                                        <option value="material-icons-outlined">Outlined</option>
                                        <option value="material-icons-round">Round</option>
                                        <option value="material-icons-sharp">Sharp</option>
                                        <option value="material-icons-two-tone">Two Tone</option>
                                    </select>
                                </div>
                                <div id="mi-icon-category-filter"
                                    style="margin-bottom: 10px; display: flex; flex-wrap: wrap; gap: 6px;">
                                    <!-- Material Icons カテゴリーボタンはJSで動的に生成されます -->
                                </div>
                                <div id="mi-icon-list-container"
                                    style="display: flex; flex-wrap: wrap; gap: 10px; max-height: 400px; overflow-y: auto;">
                                    <!-- Material Icons はここにJavaScriptで描画されます -->
                                </div>
                            </div>
                        </div>
                        <div class="sidebar-tab-content" data-tab-content="inspector">
                            <div id="inspector"></div> <!-- 旧インスペクターのコンテナ -->
                            <div id="no-selection-message" style="display:none;">要素が選択されていません</div>
                        </div>
                        <div class="sidebar-tab-content" data-tab-content="page-settings">
                            <h3>ページ全体のカスタムCSS</h3>
                            <p style="font-size:12px; color: #6c757d; margin-bottom: 8px;">ここに記述したCSSは、すべてのスライドに適用されます。
                            </p>
                            <div id="global-css-input"
                                style="height: 300px; border: 1px solid var(--border-color); border-radius: var(--border-radius);">
                            </div>
                            <button id="save-global-css-btn" class="sidebar-add-btn"
                                style="width:100%; margin-top: 10px; justify-content: center;">ページCSSを適用</button>
                        </div>
                        <div class="sidebar-tab-content" data-tab-content="chat">
                            <div id="chat-panel">
                                <div id="ai-controls"
                                    style="margin-bottom: 10px; display: flex; flex-direction: column; gap: 8px;">
                                    <div style="display: flex; gap: 8px;">
                                        <button id="restore-checkpoint-btn" class="sidebar-add-btn"
                                            title="AIによる直前の変更を取り消します" style="flex-grow: 1; justify-content: center;"
                                            disabled><i class="fas fa-undo"></i> AIの変更を戻す</button>
                                    </div>
                                    <label
                                        style="display: flex; align-items: center; justify-content: center; gap: 8px; padding: 8px; border: 1px solid var(--border-color); border-radius: var(--border-radius); cursor: pointer;">
                                        <i class="fas fa-magic-wand-sparkles"></i>
                                        <span>自律モード</span>
                                        <div class="toggle-switch">
                                            <input type="checkbox" id="autonomous-mode-toggle">
                                            <span class="slider"></span>
                                        </div>
                                    </label>
                                </div>
                                <div id="chat-messages"
                                    style="height: 250px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; margin-bottom: 10px; border-radius: var(--border-radius);">
                                </div>
                                <div id="chat-input-container" style="display: flex;">
                                    <input type="text" id="chat-input"
                                        style="flex-grow: 1; padding: 8px; border: 1px solid var(--border-color); border-radius: var(--border-radius) 0 0 var(--border-radius);"
                                        placeholder="AIにスライドの変更を指示...">
                                    <button id="send-chat-btn"
                                        style="padding: 8px 15px; border-radius: 0 var(--border-radius) var(--border-radius) 0; border: 1px solid var(--border-color); border-left: none; background: var(--primary-color); color: white; cursor: pointer;">送信</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </aside>
                <div id="main-canvas-area"
                    style="flex-grow: 1; display: flex; justify-content: center; align-items: center; padding: 24px; overflow: hidden; min-width: 0; min-height: 0;">
                    <div id="slide-wrapper"> <!-- slide-wrapperのスタイルは既存のmain-pane内のものとほぼ同じはず -->
                        <div id="slide-canvas"></div>
                    </div>
                </div>
            </div>
            <div id="bottom-pane"
                style="flex-shrink: 0; height: 140px; background-color: var(--bg-white); border-top: 1px solid var(--border-color); padding: 8px; overflow: hidden; display: flex; align-items: center;">
                <div id="slide-list-container">
                    <ul id="slide-list"
                        style="list-style: none; padding: 0; margin: 0; display: flex; flex-direction: row; align-items: center; width: 100%; height: 100%;">
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div id="presentation-view">
        <div id="presentation-slide-container"></div>
    </div>

    <!-- グラフ作成用モーダル -->
    <div class="modal micromodal-slide" id="chart-modal" aria-hidden="true">
        <div class="modal__overlay" tabindex="-1" data-micromodal-close>
            <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="chart-modal-title"
                style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
                <button class="modal__close" aria-label="Close modal" data-micromodal-close
                    style="position: absolute; top: 16px; right: 16px; background: none; border: none; font-size: 24px; color: #6c757d; cursor: pointer; z-index: 1001;">&times;</button>
                <main class="modal__content" id="chart-modal-content" style="padding: 24px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; align-items: start;">
                        <!-- 左側：設定パネル -->
                        <div style="background: #f8f9fa; border-radius: 12px; padding: 20px;">
                            <form id="chart-create-form">
                                <!-- グラフ種類選択 -->
                                <div style="margin-bottom: 20px;">
                                    <h3 style="margin: 0 0 12px 0; font-size: 16px; color: #495057;">グラフの種類</h3>
                                    <div
                                        style="display: grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 8px;">
                                        <button type="button" class="chart-type-btn" data-type="bar"
                                            style="display: flex; flex-direction: column; align-items: center; padding: 12px 8px; border: 2px solid #dee2e6; border-radius: 8px; background: white; cursor: pointer; transition: all 0.2s;">
                                            <i class="fas fa-chart-bar"
                                                style="font-size: 20px; margin-bottom: 4px; color: #6c757d;"></i>
                                            <span style="font-size: 11px; color: #6c757d;">棒グラフ</span>
                                        </button>
                                        <button type="button" class="chart-type-btn" data-type="line"
                                            style="display: flex; flex-direction: column; align-items: center; padding: 12px 8px; border: 2px solid #dee2e6; border-radius: 8px; background: white; cursor: pointer; transition: all 0.2s;">
                                            <i class="fas fa-chart-line"
                                                style="font-size: 20px; margin-bottom: 4px; color: #6c757d;"></i>
                                            <span style="font-size: 11px; color: #6c757d;">折れ線</span>
                                        </button>
                                        <button type="button" class="chart-type-btn" data-type="pie"
                                            style="display: flex; flex-direction: column; align-items: center; padding: 12px 8px; border: 2px solid #dee2e6; border-radius: 8px; background: white; cursor: pointer; transition: all 0.2s;">
                                            <i class="fas fa-chart-pie"
                                                style="font-size: 20px; margin-bottom: 4px; color: #6c757d;"></i>
                                            <span style="font-size: 11px; color: #6c757d;">円グラフ</span>
                                        </button>
                                        <button type="button" class="chart-type-btn" data-type="doughnut"
                                            style="display: flex; flex-direction: column; align-items: center; padding: 12px 8px; border: 2px solid #dee2e6; border-radius: 8px; background: white; cursor: pointer; transition: all 0.2s;">
                                            <i class="fas fa-dot-circle"
                                                style="font-size: 20px; margin-bottom: 4px; color: #6c757d;"></i>
                                            <span style="font-size: 11px; color: #6c757d;">ドーナツ</span>
                                        </button>
                                        <button type="button" class="chart-type-btn" data-type="radar"
                                            style="display: flex; flex-direction: column; align-items: center; padding: 12px 8px; border: 2px solid #dee2e6; border-radius: 8px; background: white; cursor: pointer; transition: all 0.2s;">
                                            <i class="fas fa-project-diagram"
                                                style="font-size: 20px; margin-bottom: 4px; color: #6c757d;"></i>
                                            <span style="font-size: 11px; color: #6c757d;">レーダー</span>
                                        </button>
                                    </div>
                                </div>

                                <!-- データ入力 -->
                                <div style="margin-bottom: 20px;">
                                    <h3 style="margin: 0 0 12px 0; font-size: 16px; color: #495057;">データ</h3>
                                    <div style="display: grid; gap: 12px;">
                                        <div>
                                            <label
                                                style="display: block; margin-bottom: 4px; font-size: 13px; color: #6c757d; font-weight: 500;">タイトル</label>
                                            <input type="text" id="chart-title" placeholder="グラフタイトル"
                                                style="width: 100%; padding: 10px 12px; border: 1px solid #ced4da; border-radius: 6px; font-size: 14px;">
                                        </div>
                                        <div>
                                            <label
                                                style="display: block; margin-bottom: 4px; font-size: 13px; color: #6c757d; font-weight: 500;">データセット名</label>
                                            <input type="text" id="chart-dataset-label" value="Dataset" required
                                                style="width: 100%; padding: 10px 12px; border: 1px solid #ced4da; border-radius: 6px; font-size: 14px;">
                                        </div>
                                        <div>
                                            <label
                                                style="display: block; margin-bottom: 4px; font-size: 13px; color: #6c757d; font-weight: 500;">ラベル（カンマ区切り）</label>
                                            <input type="text" id="chart-labels" value="A,B,C" required
                                                style="width: 100%; padding: 10px 12px; border: 1px solid #ced4da; border-radius: 6px; font-size: 14px;">
                                        </div>
                                        <div>
                                            <label
                                                style="display: block; margin-bottom: 4px; font-size: 13px; color: #6c757d; font-weight: 500;">値（カンマ区切り）</label>
                                            <input type="text" id="chart-data" value="10,20,30" required
                                                style="width: 100%; padding: 10px 12px; border: 1px solid #ced4da; border-radius: 6px; font-size: 14px;">
                                        </div>
                                    </div>
                                </div>

                                <!-- スタイル設定 -->
                                <div style="margin-bottom: 20px;">
                                    <h3 style="margin: 0 0 12px 0; font-size: 16px; color: #495057;">スタイル</h3>
                                    <div style="display: grid; gap: 16px;">
                                        <div>
                                            <label
                                                style="display: block; margin-bottom: 8px; font-size: 13px; color: #6c757d; font-weight: 500;">カラーパレット</label>
                                            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                                <button type="button" class="color-palette-btn"
                                                    data-colors="#007bff,#28a745,#dc3545,#ffc107,#6f42c1"
                                                    style="width: 40px; height: 40px; border: 2px solid #dee2e6; border-radius: 8px; cursor: pointer; background: linear-gradient(45deg, #007bff 0%, #007bff 20%, #28a745 20%, #28a745 40%, #dc3545 40%, #dc3545 60%, #ffc107 60%, #ffc107 80%, #6f42c1 80%);"></button>
                                                <button type="button" class="color-palette-btn"
                                                    data-colors="#e74c3c,#f39c12,#f1c40f,#2ecc71,#3498db"
                                                    style="width: 40px; height: 40px; border: 2px solid #dee2e6; border-radius: 8px; cursor: pointer; background: linear-gradient(45deg, #e74c3c 0%, #e74c3c 20%, #f39c12 20%, #f39c12 40%, #f1c40f 40%, #f1c40f 60%, #2ecc71 60%, #2ecc71 80%, #3498db 80%);"></button>
                                                <button type="button" class="color-palette-btn"
                                                    data-colors="#8e44ad,#9b59b6,#e67e22,#d35400,#c0392b"
                                                    style="width: 40px; height: 40px; border: 2px solid #dee2e6; border-radius: 8px; cursor: pointer; background: linear-gradient(45deg, #8e44ad 0%, #8e44ad 20%, #9b59b6 20%, #9b59b6 40%, #e67e22 40%, #e67e22 60%, #d35400 60%, #d35400 80%, #c0392b 80%);"></button>
                                            </div>
                                            <input type="text" id="chart-colors" placeholder="カスタム色（カンマ区切り）"
                                                style="width: 100%; padding: 8px 12px; border: 1px solid #ced4da; border-radius: 6px; font-size: 12px; margin-top: 8px;">
                                        </div>

                                        <div>
                                            <label
                                                style="display: block; margin-bottom: 8px; font-size: 13px; color: #6c757d; font-weight: 500;">線の太さ:
                                                <span id="line-width-value">2</span>px</label>
                                            <input type="range" id="chart-line-width" min="1" max="10" value="2"
                                                style="width: 100%; height: 6px; border-radius: 3px; background: #ddd; outline: none;">
                                        </div>

                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                                            <label
                                                style="display: flex; align-items: center; font-size: 14px; color: #495057; cursor: pointer;">
                                                <input type="checkbox" id="chart-show-legend" checked
                                                    style="margin-right: 8px; transform: scale(1.2);">
                                                凡例を表示
                                            </label>
                                            <label
                                                style="display: flex; align-items: center; font-size: 14px; color: #495057; cursor: pointer;">
                                                <input type="checkbox" id="chart-show-grid" checked
                                                    style="margin-right: 8px; transform: scale(1.2);">
                                                グリッド線を表示
                                            </label>
                                        </div>
                                    </div>
                                </div>

                                <button type="submit"
                                    style="width: 100%; padding: 12px; background: var(--primary-color); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: transform 0.2s;">
                                    <i class="fas fa-plus" style="margin-right: 8px;"></i>グラフを作成
                                </button>
                            </form>
                        </div>

                        <!-- 右側：プレビュー -->
                        <div
                            style="background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
                            <h3 style="margin: 0 0 16px 0; font-size: 16px; color: #495057; text-align: center;">プレビュー
                            </h3>
                            <div style="position: relative; height: 400px;">
                                <canvas id="chart-preview" style="width: 100%; height: 100%;"></canvas>
                            </div>
                        </div>
                    </div>
                </main>
            </div>
        </div>
    </div>

    <script>
        // グラフ作成モーダルのsubmitでグラフを追加
        document.addEventListener('DOMContentLoaded', function () {
            // QRコード生成モーダル追加
            if (!document.getElementById('qr-modal')) {
                const qrModal = document.createElement('div');
                qrModal.className = 'modal micromodal-slide';
                qrModal.id = 'qr-modal';
                qrModal.setAttribute('aria-hidden', 'true');
                qrModal.innerHTML = `
            <div class="modal__overlay" tabindex="-1" data-micromodal-close>
                <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="qr-modal-title" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
                    <button class="modal__close" aria-label="Close modal" data-micromodal-close style="position: absolute; top: 16px; right: 16px; background: none; border: none; font-size: 24px; color: #6c757d; cursor: pointer; z-index: 1001;">&times;</button>
                    <main class="modal__content" id="qr-modal-content" style="padding: 24px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; align-items: start;">
                            <!-- 左側：設定パネル -->
                            <div style="background: #f8f9fa; border-radius: 12px; padding: 20px;">
                                <form id="qr-create-form">
                                    <!-- 基本設定 -->
                                    <div style="margin-bottom: 20px;">
                                        <h3 style="margin: 0 0 12px 0; font-size: 16px; color: #495057;">基本設定</h3>
                                        <div style="display: grid; gap: 12px;">
                                            <div>
                                                <label style="display: block; margin-bottom: 4px; font-size: 13px; color: #6c757d; font-weight: 500;">QRコード内容</label>
                                                <input type="text" id="qr-text" value="" required placeholder="URLやテキストを入力" style="width: 100%; padding: 10px 12px; border: 1px solid #ced4da; border-radius: 6px; font-size: 14px;">
                                            </div>
                                            <div>
                                                <label style="display: block; margin-bottom: 8px; font-size: 13px; color: #6c757d; font-weight: 500;">サイズ: <span id="qr-size-value">256</span>px</label>
                                                <input type="range" id="qr-size" value="256" min="128" max="512" step="16" style="width: 100%; height: 6px; border-radius: 3px; background: #ddd; outline: none;">
                                            </div>
                                        </div>
                                    </div>

                                    <!-- カラー設定 -->
                                    <div style="margin-bottom: 20px;">
                                        <h3 style="margin: 0 0 12px 0; font-size: 16px; color: #495057;">カラー</h3>
                                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                                            <div style="text-align: center;">
                                                <label style="display: block; margin-bottom: 8px; font-size: 13px; color: #6c757d; font-weight: 500;">QRコード色</label>
                                                <div style="position: relative; display: inline-block;">
                                                    <input type="color" id="qr-color" value="#000000" style="width: 60px; height: 60px; border: 3px solid #fff; border-radius: 50%; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                                                </div>
                                            </div>
                                            <div style="text-align: center;">
                                                <label style="display: block; margin-bottom: 8px; font-size: 13px; color: #6c757d; font-weight: 500;">背景色</label>
                                                <div style="position: relative; display: inline-block;">
                                                    <input type="color" id="qr-bg-color" value="#ffffff" style="width: 60px; height: 60px; border: 3px solid #fff; border-radius: 50%; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- スタイル設定 -->
                                    <div style="margin-bottom: 20px;">
                                        <h3 style="margin: 0 0 12px 0; font-size: 16px; color: #495057;">スタイル</h3>
                                        <div style="display: grid; gap: 16px;">
                                            <div>
                                                <label style="display: block; margin-bottom: 8px; font-size: 13px; color: #6c757d; font-weight: 500;">ドット形状</label>
                                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                                                    <button type="button" class="qr-style-btn" data-style="square" style="padding: 12px; border: 2px solid #dee2e6; border-radius: 8px; background: white; cursor: pointer; text-align: center; font-size: 12px; transition: all 0.2s;">四角</button>
                                                    <button type="button" class="qr-style-btn" data-style="dots" style="padding: 12px; border: 2px solid #dee2e6; border-radius: 8px; background: white; cursor: pointer; text-align: center; font-size: 12px; transition: all 0.2s;">丸</button>
                                                    <button type="button" class="qr-style-btn" data-style="rounded" style="padding: 12px; border: 2px solid #dee2e6; border-radius: 8px; background: white; cursor: pointer; text-align: center; font-size: 12px; transition: all 0.2s;">角丸</button>
                                                    <button type="button" class="qr-style-btn" data-style="classy" style="padding: 12px; border: 2px solid #dee2e6; border-radius: 8px; background: white; cursor: pointer; text-align: center; font-size: 12px; transition: all 0.2s;">クラッシー</button>
                                                    <button type="button" class="qr-style-btn" data-style="classy-rounded" style="padding: 12px; border: 2px solid #dee2e6; border-radius: 8px; background: white; cursor: pointer; text-align: center; font-size: 12px; transition: all 0.2s;">クラッシー丸</button>
                                                    <button type="button" class="qr-style-btn" data-style="extra-rounded" style="padding: 12px; border: 2px solid #dee2e6; border-radius: 8px; background: white; cursor: pointer; text-align: center; font-size: 12px; transition: all 0.2s;">超丸</button>
                                                </div>
                                            </div>
                                            
                                            <div>
                                                <label style="display: block; margin-bottom: 8px; font-size: 13px; color: #6c757d; font-weight: 500;">枠線形状</label>
                                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                                                    <button type="button" class="qr-corner-btn" data-corner="square" style="padding: 12px; border: 2px solid #dee2e6; border-radius: 8px; background: white; cursor: pointer; text-align: center; font-size: 12px; transition: all 0.2s;">四角</button>
                                                    <button type="button" class="qr-corner-btn" data-corner="dot" style="padding: 12px; border: 2px solid #dee2e6; border-radius: 8px; background: white; cursor: pointer; text-align: center; font-size: 12px; transition: all 0.2s;">丸</button>
                                                    <button type="button" class="qr-corner-btn" data-corner="extra-rounded" style="padding: 12px; border: 2px solid #dee2e6; border-radius: 8px; background: white; cursor: pointer; text-align: center; font-size: 12px; transition: all 0.2s;">超丸</button>
                                                </div>
                                            </div>

                                            <div>
                                                <label style="display: block; margin-bottom: 8px; font-size: 13px; color: #6c757d; font-weight: 500;">ロゴ画像（任意）</label>
                                                <input type="file" id="qr-logo-upload" accept="image/*" style="width: 100%; padding: 10px; border: 1px solid #ced4da; border-radius: 6px; font-size: 14px;">
                                            </div>
                                        </div>
                                    </div>

                                    <button type="submit" style="width: 100%; padding: 12px; background: var(--primary-color); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; transition: transform 0.2s;">
                                        <i class="fas fa-plus" style="margin-right: 8px;"></i>スライドに追加
                                    </button>
                                </form>
                            </div>

                            <!-- 右側：プレビュー -->
                            <div style="background: white; border-radius: 12px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
                                <h3 style="margin: 0 0 16px 0; font-size: 16px; color: #495057; text-align: center;">プレビュー</h3>
                                <div style="display: flex; justify-content: center; align-items: center; min-height: 300px;">
                                    <div id="qr-preview" style="display: inline-block; padding: 20px; background: #fafbfc; border: 2px dashed #dee2e6; border-radius: 12px; min-width: 200px; min-height: 200px; text-align: center; color: #6c757d;">
                                        QRコード内容を入力してください
                                    </div>
                                </div>
                                <div id="qr-warning" style="display: none; color: #dc3545; font-size: 13px; margin-top: 12px; padding: 8px; background: #f8d7da; border-radius: 6px; text-align: center;"></div>
                            </div>
                        </div>
                    </main>
                </div>
            </div>`;
                document.body.appendChild(qrModal);
            }
            // qr-code-styling用QRコードプレビュー・生成
            let qrStylingInstance = null;
            const qrTextInput = document.getElementById('qr-text');
            const qrSizeInput = document.getElementById('qr-size');
            const qrColorInput = document.getElementById('qr-color');
            const qrBgColorInput = document.getElementById('qr-bg-color');
            const qrDotStyleInput = document.getElementById('qr-dot-style');
            const qrCornerStyleInput = document.getElementById('qr-corner-style');
            const qrLogoUpload = document.getElementById('qr-logo-upload');
            let qrLogoDataUrl = null;

            // QRコードスタイル変数
            let selectedDotStyle = 'square';
            let selectedCornerStyle = 'square';

            function updateQRPreview() {
                const text = qrTextInput.value;
                const size = parseInt(qrSizeInput.value) || 256;
                const color = qrColorInput.value;
                const bgColor = qrBgColorInput.value;
                const preview = document.getElementById('qr-preview');
                const warning = document.getElementById('qr-warning');

                // プレビューエリアをクリア
                preview.innerHTML = '';

                // テキストが空の場合はプレースホルダーを表示
                if (!text) {
                    preview.style.display = 'flex';
                    preview.style.alignItems = 'center';
                    preview.style.justifyContent = 'center';
                    preview.innerHTML = '<span style="color: #6c757d;">QRコード内容を入力してください</span>';
                    return;
                }

                // typo検出（正しいURLは警告しない、1行で記述）
                const typoPattern = /(?:^|[^a-zA-Z])(h{1,2}t{1,2}p[s]?:\/\/|ttp[s]?:\/\/|https?:;\/\/|https?:\/\/\/|https?:\/\/$|https?:\/\/:|https?:\/\/\s|https?:\/\/\W|https?:\/{1,2}[^a-zA-Z0-9])/i;
                const correctPattern = /^https?:\/\/[a-zA-Z0-9]/;

                if (typoPattern.test(text) && !correctPattern.test(text.trim())) {
                    warning.style.display = 'block';
                    warning.textContent = 'URLにタイプミスがあります（例: hhtps://, https;//, https:/, http;//, ttp://, https::// など）。正しいURLか確認してください。';
                } else {
                    warning.style.display = 'none';
                    warning.textContent = '';
                }

                // QRコード生成
                preview.style.display = 'block';
                qrStylingInstance = new window.QRCodeStyling({
                    width: size,
                    height: size,
                    data: text,
                    image: qrLogoDataUrl,
                    dotsOptions: {
                        color: color,
                        type: selectedDotStyle
                    },
                    backgroundOptions: {
                        color: bgColor
                    },
                    cornersSquareOptions: {
                        type: selectedCornerStyle,
                        color: color
                    },
                    cornersDotOptions: {
                        type: selectedCornerStyle,
                        color: color
                    }
                });
                qrStylingInstance.append(preview);
            }

            // ロゴ画像アップロード
            if (qrLogoUpload) {
                qrLogoUpload.addEventListener('change', function (e) {
                    const file = e.target.files[0];
                    if (!file) {
                        qrLogoDataUrl = null;
                        updateQRPreview();
                        return;
                    }
                    const reader = new FileReader();
                    reader.onload = function (ev) {
                        qrLogoDataUrl = ev.target.result;
                        updateQRPreview();
                    };
                    reader.readAsDataURL(file);
                });
            }

            // QRサイズスライダーの値表示更新
            const qrSizeValueSpan = document.getElementById('qr-size-value');
            if (qrSizeInput && qrSizeValueSpan) {
                qrSizeInput.addEventListener('input', function () {
                    qrSizeValueSpan.textContent = this.value;
                    updateQRPreview();
                });
            }

            // QRドット形状ボタンのイベント
            document.addEventListener('click', function (e) {
                if (e.target.classList.contains('qr-style-btn')) {
                    document.querySelectorAll('.qr-style-btn').forEach(btn => {
                        btn.style.borderColor = '#dee2e6';
                        btn.style.backgroundColor = 'white';
                        btn.style.color = '#495057';
                    });
                    e.target.style.borderColor = 'var(--primary-color)';
                    e.target.style.backgroundColor = 'var(--primary-color)';
                    e.target.style.color = 'white';
                    selectedDotStyle = e.target.dataset.style;
                    updateQRPreview();
                }
            });

            // QR枠線形状ボタンのイベント
            document.addEventListener('click', function (e) {
                if (e.target.classList.contains('qr-corner-btn')) {
                    document.querySelectorAll('.qr-corner-btn').forEach(btn => {
                        btn.style.borderColor = '#dee2e6';
                        btn.style.backgroundColor = 'white';
                        btn.style.color = '#495057';
                    });
                    e.target.style.borderColor = 'var(--primary-color)';
                    e.target.style.backgroundColor = 'var(--primary-color)';
                    e.target.style.color = 'white';
                    selectedCornerStyle = e.target.dataset.corner;
                    updateQRPreview();
                }
            });

            // 各種入力イベント
            [qrTextInput, qrColorInput, qrBgColorInput].forEach(input => {
                if (input) input.addEventListener('input', updateQRPreview);
            });

            // QRコード生成フォームsubmit
            const qrForm = document.getElementById('qr-create-form');
            if (qrForm) {
                qrForm.onsubmit = async function (ev) {
                    ev.preventDefault();
                    if (!qrStylingInstance) return;
                    // QRコードをcanvasに描画し、dataURL化
                    const canvas = qrStylingInstance._canvas;
                    if (canvas) {
                        const imgUrl = canvas.toDataURL();
                        if (window.App && App.addElement) {
                            App.addElement('image', imgUrl);
                        }
                        if (typeof MicroModal !== "undefined") {
                            MicroModal.close('qr-modal');
                        }
                    }
                };
            }

            let chartInstance = null; // Chart.jsインスタンスを保持する変数

            // グラフの色を生成するヘルパー関数
            function generateChartColors(count, existingColors = []) {
                const defaultColors = [
                    '#007bff', '#28a745', '#dc3545', '#ffc107', '#6f42c1',
                    '#e83e8c', '#20c997', '#fd7e14', '#6c757d', '#0dcaf0'
                ];
                let colors = existingColors.filter(Boolean); // 空の文字列を除外
                if (colors.length < count) {
                    colors = colors.concat(defaultColors.slice(0, count - colors.length));
                }
                return colors;
            }

            function updateChartPreview() {
                // 新UI: 選択中のボタンから取得
                const selectedBtn = document.querySelector('.chart-type-btn.selected');
                let chartType = selectedBtn ? selectedBtn.dataset.type : null;
                // 旧UI fallback
                if (!chartType) {
                    const select = document.getElementById('chart-type');
                    chartType = select ? select.value : 'bar';
                }
                const labels = document.getElementById('chart-labels').value.split(',').map(s => s.trim());
                const datasetLabel = document.getElementById('chart-dataset-label').value;
                const dataValues = document.getElementById('chart-data').value.split(',').map(s => Number(s.trim()));
                const customColorsInput = document.getElementById('chart-colors').value;
                const customColors = customColorsInput.split(',').map(s => s.trim());
                const lineWidth = Number(document.getElementById('chart-line-width')?.value) || 2;
                const showLegend = document.getElementById('chart-show-legend')?.checked ?? true;
                const chartTitle = document.getElementById('chart-title')?.value || datasetLabel;
                const showGrid = document.getElementById('chart-show-grid')?.checked ?? true;

                // データの数に合わせて色を生成
                const colors = generateChartColors(dataValues.length, customColors);

                const chartConfig = {
                    type: chartType,
                    data: {
                        labels: labels,
                        datasets: [{
                            label: datasetLabel,
                            data: dataValues,
                            backgroundColor: chartType === 'pie' || chartType === 'doughnut' ? colors : colors[0],
                            borderColor: chartType === 'pie' || chartType === 'doughnut' ? colors : colors[0],
                            borderWidth: chartType === 'line' || chartType === 'radar' ? lineWidth : 1,
                            pointBackgroundColor: chartType === 'radar' ? colors : undefined
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'top',
                                display: showLegend
                            },
                            title: {
                                display: !!chartTitle,
                                text: chartTitle
                            }
                        },
                        scales: (chartType === 'pie' || chartType === 'doughnut')
                            ? {}
                            : {
                                y: {
                                    beginAtZero: true,
                                    display: true,
                                    grid: { display: showGrid }
                                },
                                x: {
                                    display: true,
                                    grid: { display: showGrid }
                                }
                            }
                    }
                };

                const ctx = document.getElementById('chart-preview').getContext('2d');
                if (chartInstance) {
                    chartInstance.destroy(); // 既存のChartインスタンスがあれば破棄
                }
                chartInstance = new Chart(ctx, chartConfig);
            }

            // 各入力フィールドにイベントリスナーを追加
            const chartInputs = [
                document.getElementById('chart-type'),
                document.getElementById('chart-labels'),
                document.getElementById('chart-dataset-label'),
                document.getElementById('chart-data'),
                document.getElementById('chart-colors'),
                document.getElementById('chart-line-width'),
                document.getElementById('chart-show-legend'),
                document.getElementById('chart-title'),
                document.getElementById('chart-show-grid')
            ];
            chartInputs.forEach(input => {
                if (input) input.addEventListener('input', updateChartPreview);
                if (input && input.type === 'checkbox') input.addEventListener('change', updateChartPreview);
            });

            // グラフ種類ボタンの初期選択状態を設定
            // 最初のボタンを選択状態にする
            const chartTypeBtns = document.querySelectorAll('.chart-type-btn');
            if (chartTypeBtns.length > 0 && !document.querySelector('.chart-type-btn.selected')) {
                chartTypeBtns[0].classList.add('selected');
            }

            // フォーム表示時に初期プレビューを生成
            if (typeof MicroModal !== "undefined") {
                MicroModal.init({
                    onShow: modal => {
                        if (modal.id === 'chart-modal') {
                            // グラフ種類ボタンの選択状態を維持
                            if (!document.querySelector('.chart-type-btn.selected') && chartTypeBtns.length > 0) {
                                chartTypeBtns[0].classList.add('selected');
                            }
                            updateChartPreview();
                        }
                    }
                });
            }

            // グラフ作成モーダルのsubmitでグラフを追加
            const form = document.getElementById('chart-create-form');
            if (form) {
                form.onsubmit = function (ev) {
                    ev.preventDefault();
                    // updateChartPreviewで生成された現在のchartConfigを利用
                    if (!chartInstance) {
                        console.error("Chart instance not found for submission.");
                        return;
                    }

                    const slide = window.App && App.getActiveSlide ? App.getActiveSlide() : null;
                    if (!slide) return;

                    const newEl = {
                        id: App.generateId('el'),
                        type: 'chart',
                        content: chartInstance.config, // Chart.jsのコンフィグをそのまま保存
                        style: { top: 20, left: 20, width: 50, height: 30, zIndex: slide.elements.length + 1, rotation: 0, animation: '' }
                    };
                    slide.elements.push(newEl);
                    App.state.selectedElementIds = [newEl.id];
                    App.saveState();
                    App.render();
                    MicroModal.close('chart-modal');
                };
            }
        });
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const sidebar = document.getElementById('left-sidebar');
            const handle = document.getElementById('sidebar-resize-handle');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;
            const iconTabWidth = 60; // Includes padding and border

            handle.addEventListener('mousedown', function (e) {
                // Only resize if the content panel is visible
                if (sidebar.querySelector('#sidebar-content').style.display === 'none') return;
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.offsetWidth;
                document.body.style.cursor = 'ew-resize';
                e.preventDefault();
            });

            document.addEventListener('mousemove', function (e) {
                if (!isResizing) return;
                let newWidth = startWidth + (e.clientX - startX);

                // The resizable part is the content panel, so total width is content + icon tab width
                // Minimum content panel width could be ~180px, so total min width is ~240px
                newWidth = Math.max(iconTabWidth + 180, Math.min(newWidth, 600));

                sidebar.style.width = newWidth + 'px';
            });

            document.addEventListener('mouseup', function () {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    handle.style.background = '';
                }
            });
        });
    </script>

    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- qr-code-styling CDN -->
    <script src="https://cdn.jsdelivr.net/npm/qr-code-styling@1.6.0/lib/qr-code-styling.js"></script>
    <!-- Fuse.js を読み込み：アイコンあいまい検索用 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.6.2/fuse.min.js"></script>
    <link rel="stylesheet" href="mainmodal.css">
    <script src="https://cdn.jsdelivr.net/npm/micromodal@0.6.1/dist/micromodal.min.js"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
    <!-- CodeMirror 6 will be loaded via JS module import -->
    <script src="ai.js"></script>

    <script type="module">
        // =================================================================
        // GuideLineManager: スマートガイドとスナップ機能の管理
        // =================================================================
        class GuideLineManager {
            constructor(container) {
                this.container = container;
                this.guides = [];
                this.SNAP_THRESHOLD = 5; // スナップ閾値(px)
            }

            clear() {
                this.container.querySelectorAll('.guide-line').forEach(el => el.remove());
                this.guides = [];
            }

            addGuide(orientation, position) {
                const guide = document.createElement('div');
                guide.className = `guide-line ${orientation}`;
                if (orientation === 'horizontal') {
                    guide.style.top = `${position}px`;
                } else {
                    guide.style.left = `${position}px`;
                }
                this.container.appendChild(guide);
            }

            calculateSnapGuides(draggingBounds, staticElementsBounds, canvasBounds) {
                const snapOffset = { x: 0, y: 0 };
                const guidesToShow = new Set(); // 重複するガイドを防ぐ

                const verticalSnapLines = [canvasBounds.left, canvasBounds.centerX, canvasBounds.right];
                const horizontalSnapLines = [canvasBounds.top, canvasBounds.centerY, canvasBounds.bottom];

                staticElementsBounds.forEach(bounds => {
                    verticalSnapLines.push(bounds.left, bounds.centerX, bounds.right);
                    horizontalSnapLines.push(bounds.top, bounds.centerY, bounds.bottom);
                });

                let minDx = this.SNAP_THRESHOLD;
                const draggingVerticalLines = [draggingBounds.left, draggingBounds.centerX, draggingBounds.right];
                for (const dLine of draggingVerticalLines) {
                    for (const sLine of verticalSnapLines) {
                        const dist = sLine - dLine;
                        // 閾値以内の距離のみを考慮
                        if (Math.abs(dist) <= this.SNAP_THRESHOLD && Math.abs(dist) < Math.abs(minDx)) {
                            minDx = dist;
                        }
                    }
                }
                if (minDx !== this.SNAP_THRESHOLD) {
                    snapOffset.x = minDx;
                    draggingVerticalLines.forEach(l => {
                        guidesToShow.add(`vertical-${l + snapOffset.x}`);
                    });
                }

                let minDy = this.SNAP_THRESHOLD;
                const draggingHorizontalLines = [draggingBounds.top, draggingBounds.centerY, draggingBounds.bottom];
                for (const dLine of draggingHorizontalLines) {
                    for (const sLine of horizontalSnapLines) {
                        const dist = sLine - dLine;
                        // 閾値以内の距離のみを考慮
                        if (Math.abs(dist) <= this.SNAP_THRESHOLD && Math.abs(dist) < Math.abs(minDy)) {
                            minDy = dist;
                        }
                    }
                }
                if (minDy !== this.SNAP_THRESHOLD) {
                    snapOffset.y = minDy;
                    draggingHorizontalLines.forEach(l => {
                        guidesToShow.add(`horizontal-${l + snapOffset.y}`);
                    });
                }

                return { snapOffset, guides: Array.from(guidesToShow) };
            }
        }

        // =================================================================
        // ユーティリティ関数群
        // =================================================================
        const Utils = {
            generateId: (prefix) => `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,

            debounce: (func, wait) => {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },

            clamp: (value, min, max) => Math.min(Math.max(value, min), max),

            pixelsToPercent: (pixels, containerSize) => (pixels / containerSize) * 100,

            percentToPixels: (percent, containerSize) => (percent / 100) * containerSize
        };

        // =================================================================
        // DOM要素作成ヘルパー
        // =================================================================
        const ElementFactory = {
            createText(elData) {
                return elData.content;
            },

            createImage(elData) {
                const img = document.createElement('img');
                img.src = elData.content;
                return img;
            },

            createVideo(elData) {
                const video = document.createElement('video');
                video.style.width = '100%';
                video.style.height = '100%';
                video.src = elData.content.url || '';
                video.autoplay = !!elData.content.autoplay;
                video.loop = !!elData.content.loop;
                video.controls = elData.content.controls !== false;
                video.playsInline = true;
                return video;
            },

            createChart(elData) {
                const canvas = document.createElement('canvas');
                canvas.id = `chart-${elData.id}`;
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                setTimeout(() => {
                    if (canvas) {
                        new Chart(canvas.getContext('2d'), elData.content);
                    }
                }, 0);
                return canvas;
            },

            createTable(elData) {
                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.height = '100%';
                table.style.borderCollapse = 'collapse';

                for (let r = 0; r < elData.content.rows; r++) {
                    const tr = document.createElement('tr');
                    for (let c = 0; c < elData.content.cols; c++) {
                        const td = document.createElement('td');
                        td.textContent = elData.content.data?.[r]?.[c] ?? '';
                        td.style.border = '1px solid #888';
                        td.style.padding = '4px';
                        tr.appendChild(td);
                    }
                    table.appendChild(tr);
                }
                return table;
            },

            createIcon(elData) {
                if (elData.iconType === 'fa') {
                    const iTag = document.createElement('i');
                    iTag.className = elData.content;
                    iTag.style.color = elData.style.color || 'inherit';
                    iTag.style.fontSize = elData.style.fontSize ? `${elData.style.fontSize}px` : 'inherit';
                    iTag.style.position = 'absolute';
                    iTag.style.left = '50%';
                    iTag.style.top = '50%';
                    iTag.style.transform = 'translate(-50%, -50%)';
                    return iTag;
                } else if (elData.iconType === 'mi') {
                    const spanTag = document.createElement('span');
                    spanTag.className = elData.content;
                    spanTag.textContent = elData.miContent;
                    spanTag.style.color = elData.style.color || 'inherit';
                    spanTag.style.fontSize = elData.style.fontSize ? `${elData.style.fontSize}px` : 'inherit';
                    spanTag.style.position = 'absolute';
                    spanTag.style.left = '50%';
                    spanTag.style.top = '50%';
                    spanTag.style.transform = 'translate(-50%, -50%)';
                    return spanTag;
                }
                return null;
            },

            createIframe(elData) {
                const container = document.createDocumentFragment();

                const iframe = document.createElement('iframe');
                iframe.src = elData.content.url;
                iframe.style.width = '100%';
                iframe.style.height = '100%';
                iframe.style.border = 'none';
                iframe.sandbox = elData.content.sandbox || 'allow-scripts allow-same-origin';

                const overlay = document.createElement('div');
                overlay.className = 'iframe-overlay';
                Object.assign(overlay.style, {
                    position: 'absolute',
                    top: 0, left: 0, right: 0, bottom: 0,
                    zIndex: 10000,
                    backgroundColor: 'transparent',
                    cursor: 'move',
                });

                overlay.addEventListener('mousedown', (e) => App.handleCanvasMouseDown(e));
                overlay.addEventListener('touchstart', (e) => App.handleCanvasMouseDown(e), { passive: false });

                container.appendChild(iframe);
                container.appendChild(overlay);
                return container;
            }
        };

        // =================================================================
        // スタイル適用ヘルパー
        // =================================================================
        const StyleManager = {
            applyStyles(element, styles) {
                const height = styles.height != null ? `${styles.height}%` : 'auto';
                const width = typeof styles.width === 'number' ? `${styles.width}%` : styles.width;

                Object.assign(element.style, {
                    top: `${styles.top}%`,
                    left: `${styles.left}%`,
                    width: width,
                    height: height,
                    zIndex: styles.zIndex,
                    transform: `rotate(${styles.rotation || 0}deg)`,
                    color: styles.color,
                    fontSize: styles.fontSize ? `${styles.fontSize}px` : null,
                    fontFamily: styles.fontFamily || ''
                });

                // 縦書き対応
                if (styles.vertical) {
                    element.style.writingMode = 'vertical-rl';
                    element.style.textOrientation = 'mixed';
                } else {
                    element.style.writingMode = '';
                    element.style.textOrientation = '';
                }
            },

            addResizeHandles(element) {
                ['nw', 'n', 'ne', 'w', 'e', 'sw', 's', 'se'].forEach(handleType => {
                    const handle = document.createElement('div');
                    handle.className = `resize-handle ${handleType}`;
                    handle.dataset.handle = handleType;
                    element.appendChild(handle);
                });
            }
        };

        // =================================================================
        // App: メインアプリケーション（リファクタリング版）
        // =================================================================
        const App = {
            state: {
                presentation: null, activeSlideId: null, selectedElementIds: [], isEditingText: false,
                undoStack: [], redoStack: [],
                aiCheckpoint: null, // AI変更前の状態を保存
                autonomousMode: { // 自律モードの状態
                    isActive: false,
                    intervalId: null,
                },
                interaction: {
                    isDragging: false, isResizing: false, isCtrlPressed: false, handle: null,
                    startX: 0, startY: 0, initialStates: [],
                },
                slideCanvasRect: null,
                canvasScale: 1.0, // スライド拡大率
            },
            canvasPan: { x: 0, y: 0, dragging: false, startX: 0, startY: 0, originX: 0, originY: 0 },
            elements: {},
            config: {}, // Add this line to initialize config
            cmInstances: {}, // CodeMirrorインスタンスを保持

            init() {
                this.cacheElements();
                this.guideLineManager = new GuideLineManager(this.elements.slideCanvas);
                this.aiHandler = new AIHandler(this); // AI Handlerを初期化

                // bindEvents, loadState, render, initZoomControl は loadIconData() の後に実行
                this.bindEvents();
                this.loadState();
                this.render();
                this.initZoomControl();
            },

            // アイコンデータを読み込むための新しいメソッド
            async loadIconData() {
                try {
                    const response = await fetch('icons.json');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    this.config.fontAwesomeIcons = data.fontAwesomeIcons;
                    this.config.materialIcons = data.materialIcons;

                    // アイコンに英語名(クラス名から)をaliasプロパティとして追加
                    this.config.fontAwesomeIcons.forEach(icon => {
                        const cls = icon.class.split(' ')[1] || '';
                        icon.alias = cls.replace('fa-', '');
                    });
                    this.config.materialIcons.forEach(icon => {
                        icon.alias = icon.name.toLowerCase().replace(/ /g, '_');
                    });
                    // Fuse.js を使ったアイコンのあいまい検索インスタンス
                    this.faIconFuse = new Fuse(this.config.fontAwesomeIcons, {
                        keys: ['name', 'category', 'class', 'alias'],
                        threshold: 0.4,
                        ignoreLocation: true
                    });
                    this.miIconFuse = new Fuse(this.config.materialIcons, {
                        keys: ['name', 'category', 'class', 'alias'],
                        threshold: 0.4,
                        ignoreLocation: true
                    });

                } catch (error) {
                    console.error("Failed to load icon data:", error);
                    // エラー発生時のフォールバックとして空の配列を設定
                    this.config.fontAwesomeIcons = [];
                    this.config.materialIcons = [];
                }
            },

            // DOM要素のキャッシュ - 整理版
            cacheElements() {
                this.elements = {
                    // メインコンテナ
                    appContainer: document.getElementById('app-container'),
                    toolbar: document.getElementById('toolbar'),
                    appBody: document.getElementById('app-body'),
                    leftSidebar: document.getElementById('left-sidebar'),
                    mainCanvasArea: document.getElementById('main-canvas-area'),

                    // サイドバー関連
                    sidebarTabs: document.getElementById('sidebar-tabs'),
                    sidebarContent: document.getElementById('sidebar-content'),
                    inspector: document.getElementById('inspector'),
                    noSelectionMessage: document.getElementById('no-selection-message'),
                    chatPanel: document.getElementById('chat-panel'),

                    // ツールバーボタン
                    addSlideBtn: document.getElementById('add-slide-btn'),
                    deleteSlideBtn: document.getElementById('delete-slide-btn'),
                    saveBtn: document.getElementById('save-btn'),
                    presentBtn: document.getElementById('present-btn'),
                    exportBtn: document.getElementById('export-btn'),
                    exportMenu: document.getElementById('export-menu'),

                    // 要素追加ボタン
                    addTextBtn: document.getElementById('add-text-btn'),
                    addImageBtn: document.getElementById('add-image-btn'),
                    addChartBtn: document.getElementById('add-chart-btn'),
                    addIframeBtn: document.getElementById('add-iframe-btn'),
                    imageUploadInput: document.getElementById('image-upload-input'),

                    // 整列ボタン
                    alignLeftBtn: document.getElementById('align-left-btn'),
                    alignCenterHBtn: document.getElementById('align-center-h-btn'),
                    alignRightBtn: document.getElementById('align-right-btn'),
                    alignTopBtn: document.getElementById('align-top-btn'),
                    alignCenterVBtn: document.getElementById('align-center-v-btn'),
                    alignBottomBtn: document.getElementById('align-bottom-btn'),
                    distributeHBtn: document.getElementById('distribute-h-btn'),
                    distributeVBtn: document.getElementById('distribute-v-btn'),

                    // スライド関連
                    slideList: document.getElementById('slide-list'),
                    slideCanvas: document.getElementById('slide-canvas'),

                    // アイコン関連
                    faIconListContainer: document.getElementById('fa-icon-list-container'),
                    faIconSearchInput: document.getElementById('fa-icon-search-input'),
                    faIconCategoryFilter: document.getElementById('fa-icon-category-filter'),
                    miIconListContainer: document.getElementById('mi-icon-list-container'),
                    miIconSearchInput: document.getElementById('mi-icon-search-input'),
                    miIconCategoryFilter: document.getElementById('mi-icon-category-filter'),

                    // プレゼンテーション関連
                    presentationView: document.getElementById('presentation-view'),
                    presentationSlideContainer: document.getElementById('presentation-slide-container'),

                    // AI関連
                    restoreCheckpointBtn: document.getElementById('restore-checkpoint-btn'),
                    autonomousModeToggle: document.getElementById('autonomous-mode-toggle'),
                };
            },

            loadState() {
                const savedData = localStorage.getItem('webSlideMakerData');
                if (savedData) {
                    this.state.presentation = JSON.parse(savedData);
                    this.state.activeSlideId = this.state.presentation.slides[0]?.id || null;
                } else {
                    this.createNewPresentation();
                }
                this.state.selectedElementIds = [];
                // グローバルCSSをテキストエリアに反映
                const globalCssInput = document.getElementById('global-css-input');
                if (globalCssInput) {
                    globalCssInput.value = this.state.presentation.settings.globalCss || '';
                }
                this.applyCustomCss();
            },

            saveState() {
                if (!this._skipHistory) {
                    this.state.undoStack.push(JSON.stringify(this.state.presentation));
                    if (this.state.undoStack.length > 100) this.state.undoStack.shift();
                    this.state.redoStack = [];
                }
                localStorage.setItem('webSlideMakerData', JSON.stringify(this.state.presentation));
                const saveButton = this.elements.saveBtn.querySelector('span');
                if (saveButton) {
                    const originalText = saveButton.textContent;
                    saveButton.textContent = '保存済み';
                    setTimeout(() => { saveButton.textContent = originalText; }, 1500);
                }
            },

            createNewPresentation() {
                const firstSlideId = this.generateId('slide');
                this.state.presentation = {
                    settings: { width: 1280, height: 720, globalCss: '' },
                    slides: [{
                        id: firstSlideId,
                        elements: [{
                            id: this.generateId('el'), type: 'text', content: 'タイトル',
                            style: { top: 20, left: 10, width: 80, height: null, zIndex: 1, rotation: 0, color: '#212529', fontSize: 60, fontFamily: 'sans-serif', animation: '' }
                        }, {
                            id: this.generateId('el'), type: 'text', content: 'サブタイトル',
                            style: { top: 40, left: 10, width: 80, height: null, zIndex: 2, rotation: 0, color: '#6c757d', fontSize: 32, fontFamily: 'sans-serif', animation: '' }
                        }]
                    }]
                };
                this.state.activeSlideId = firstSlideId;
            },

            render() {
                if (!this.state.presentation) return;
                requestAnimationFrame(() => {
                    this.state.slideCanvasRect = this.elements.slideCanvas.getBoundingClientRect();
                    this.renderThumbnails();
                    this.renderSlideCanvas();

                    const inspectorHasFocus = document.activeElement && this.elements.inspector.contains(document.activeElement);

                    if (!inspectorHasFocus) {
                        // 要素が選択されていれば「設定」タブをアクティブにし、インスペクターを再描画
                        if (this.state.selectedElementIds.length > 0) {
                            this.switchToTab('inspector'); // "inspector" は設定タブの data-tab 値
                            this.renderInspector();
                        } else {
                            // 要素が選択されていない場合、もし「設定」タブが開いていたらインスペクターをクリア表示
                            const inspectorTabButton = this.elements.sidebarTabs.querySelector('.sidebar-tab-button[data-tab="inspector"]');
                            if (inspectorTabButton && inspectorTabButton.classList.contains('active')) {
                                this.renderInspector(); // renderInspector handles no selection message
                            }
                        }
                    }
                    this.updateToolbarState();
                    this.applyCustomCss();
                });
            },

            // Helper function to switch sidebar tabs programmatically
            switchToTab(tabName) {
                if (!this.elements.sidebarTabs || !this.elements.sidebarContent) return;

                // Destroy CodeMirror instance if it exists
                if (this.cmInstances.elementCssEditor) {
                    this.cmInstances.elementCssEditor.destroy();
                    this.cmInstances.elementCssEditor = null;
                }

                // Update tab buttons state
                this.elements.sidebarTabs.querySelectorAll('.sidebar-tab-button').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tab === tabName);
                });

                // Update tab content visibility
                this.elements.sidebarContent.querySelectorAll('.sidebar-tab-content').forEach(content => {
                    content.classList.toggle('active', content.dataset.tabContent === tabName);
                });

                // Show/hide the entire content panel based on the tab
                const isInspectorTab = tabName === 'inspector';
                const hasSelection = this.state.selectedElementIds.length > 0;

                // Show content panel if it's not the inspector tab, or if it is and there's a selection
                const shouldShowContent = !isInspectorTab || (isInspectorTab && hasSelection);
                this.elements.sidebarContent.style.display = shouldShowContent ? 'block' : 'none';

                // Adjust sidebar width
                this.elements.leftSidebar.style.width = shouldShowContent ? '340px' : '60px';


                // Initialize editors or render specific content
                if (tabName === 'inspector') {
                    this.renderInspector();
                } else if (tabName === 'page-settings') {
                    this.initGlobalCssEditor();
                }
            },

            updateToolbarState() {
                const selectedCount = this.state.selectedElementIds.length;
                const alignButtons = [this.elements.alignLeftBtn, this.elements.alignCenterHBtn, this.elements.alignRightBtn, this.elements.alignTopBtn, this.elements.alignCenterVBtn, this.elements.alignBottomBtn];
                alignButtons.forEach(btn => btn.disabled = selectedCount < 2);
                const distributeButtons = [this.elements.distributeHBtn, this.elements.distributeVBtn];
                distributeButtons.forEach(btn => btn.disabled = selectedCount < 3);
            },

            renderThumbnails() {
                const { slides, settings } = this.state.presentation;
                this.elements.slideList.innerHTML = '';
                slides.forEach((slide, index) => {
                    const li = document.createElement('li');
                    li.className = `slide-thumbnail ${slide.id === this.state.activeSlideId ? 'active' : ''}`;
                    li.dataset.id = slide.id;
                    li.draggable = true;
                    li.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', slide.id); li.classList.add('dragging'); });
                    li.addEventListener('dragend', () => li.classList.remove('dragging'));
                    li.addEventListener('dragover', (e) => { e.preventDefault(); li.classList.add('drag-over'); });
                    li.addEventListener('dragleave', () => li.classList.remove('drag-over'));
                    li.addEventListener('drop', (e) => { e.preventDefault(); li.classList.remove('drag-over'); const fromId = e.dataTransfer.getData('text/plain'); if (fromId && fromId !== slide.id) this.moveSlide(fromId, slide.id); });
                    li.addEventListener('contextmenu', (e) => { e.preventDefault(); this.showSlideContextMenu(e, slide.id); });

                    const wrapper = document.createElement('div'); wrapper.className = 'slide-thumbnail-wrapper';
                    const content = document.createElement('div'); content.className = 'slide-thumbnail-content'; content.style.width = `${settings.width}px`; content.style.height = `${settings.height}px`;
                    slide.elements.forEach(elData => {
                        const el = this.createElementDOM(elData);
                        if (elData.style.animation) {
                            // アニメーションをリセットして再生
                            el.classList.remove('animate__animated', elData.style.animation);
                            // 強制再描画
                            void el.offsetWidth;
                            el.classList.add('animate__animated', elData.style.animation);
                            // アニメーション終了時にクラスを外す
                            el.addEventListener('animationend', function handler() {
                                el.classList.remove('animate__animated', elData.style.animation);
                                el.removeEventListener('animationend', handler);
                            });
                        }
                        content.appendChild(el);
                    });

                    const indexSpan = document.createElement('span'); indexSpan.className = 'thumbnail-index'; indexSpan.textContent = index + 1;
                    wrapper.appendChild(content);
                    li.appendChild(indexSpan);
                    li.appendChild(wrapper);
                    this.elements.slideList.appendChild(li);

                    requestAnimationFrame(() => { if (wrapper.offsetWidth > 0) content.style.transform = `scale(${wrapper.offsetWidth / settings.width})`; });
                });
            },

            renderSlideCanvas() {
                const activeSlide = this.getActiveSlide();
                const canvas = this.elements.slideCanvas;
                canvas.querySelectorAll('.slide-element, .selection-bounding-box').forEach(el => el.remove());
                // 拡大率を反映
                canvas.style.transformOrigin = "center center";
                canvas.style.transform = `scale(${this.state.canvasScale})`;
                if (!activeSlide) return;

                // パン（移動）を反映
                // canvasPanが未定義なら初期化
                if (!this.state.canvasPan) {
                    this.state.canvasPan = { x: 0, y: 0, dragging: false, startX: 0, startY: 0, originX: 0, originY: 0 };
                }
                const pan = this.state.canvasPan;
                canvas.style.transform = `scale(${this.state.canvasScale}) translate(${pan.x / this.state.canvasScale}px, ${pan.y / this.state.canvasScale}px)`;

                activeSlide.elements.forEach(elData => {
                    const el = this.createElementDOM(elData);
                    el.dataset.id = elData.id;
                    if (this.state.selectedElementIds.includes(elData.id)) {
                        el.classList.add('selected');
                        if (this.state.selectedElementIds.length === 1) this.addResizeHandles(el);
                    }
                    el.setAttribute('contenteditable', this.state.isEditingText && this.state.selectedElementIds.includes(elData.id));
                    canvas.appendChild(el);
                });
                this.renderSelectionBoundingBox();
            },

            renderSelectionBoundingBox() {
                // 既存の選択枠を全て削除
                this.elements.slideCanvas.querySelectorAll('.selection-bounding-box').forEach(el => el.remove());
                if (this.state.selectedElementIds.length <= 1) return;
                const bounds = this.getSelectedElementsBoundingBox(true);
                if (!bounds) return;
                const box = document.createElement('div');
                box.className = 'selection-bounding-box';
                Object.assign(box.style, { left: `${bounds.left}%`, top: `${bounds.top}%`, width: `${bounds.width}%`, height: `${bounds.height}%` });
                this.elements.slideCanvas.appendChild(box);
            },
            createElementDOM(elData) {
                const el = document.createElement('div');
                el.className = `slide-element ${elData.type}`;

                // StyleManagerを使ってスタイルを適用
                StyleManager.applyStyles(el, elData.style);

                // ElementFactoryを使ってコンテンツを作成
                let content = null;
                switch (elData.type) {
                    case 'text':
                        content = ElementFactory.createText(elData);
                        if (content) el.innerText = content;
                        break;
                    case 'image':
                        content = ElementFactory.createImage(elData);
                        if (content) el.appendChild(content);
                        break;
                    case 'video':
                        content = ElementFactory.createVideo(elData);
                        if (content) el.appendChild(content);
                        break;
                    case 'chart':
                        content = ElementFactory.createChart(elData);
                        if (content) el.appendChild(content);
                        break;
                    case 'table':
                        content = ElementFactory.createTable(elData);
                        if (content) el.appendChild(content);
                        break;
                    case 'icon':
                        content = ElementFactory.createIcon(elData);
                        if (content) {
                            el.style.overflow = 'visible';
                            el.appendChild(content);
                        }
                        break;
                    case 'iframe':
                        content = ElementFactory.createIframe(elData);
                        if (content) {
                            // DocumentFragmentの場合は子要素を順番に追加
                            if (content instanceof DocumentFragment) {
                                el.appendChild(content);
                            } else {
                                el.appendChild(content);
                            }
                        }
                        break;
                    default:
                        // フォールバック: 従来のメソッドを使用
                        this._createDOMForElement(el, elData);
                }
                return el;
            },

            // フォールバック用の統合メソッド
            _createDOMForElement(el, elData) {
                switch (elData.type) {
                    case 'text':
                        this._createDOMForText(el, elData);
                        break;
                    case 'image':
                        this._createDOMForImage(el, elData);
                        break;
                    case 'video':
                        this._createDOMForVideo(el, elData);
                        break;
                    case 'chart':
                        this._createDOMForChart(el, elData);
                        break;
                    case 'table':
                        this._createDOMForTable(el, elData);
                        break;
                    case 'icon':
                        this._createDOMForIcon(el, elData);
                        break;
                    case 'iframe':
                        this._createDOMForIframe(el, elData);
                        break;
                }
            },

            // 各要素タイプに対応するDOM生成ヘルパーメソッド
            _createDOMForText(el, elData) {
                el.innerText = elData.content;
            },

            _createDOMForImage(el, elData) {
                const img = document.createElement('img');
                img.src = elData.content;
                el.appendChild(img);
            },

            _createDOMForVideo(el, elData) {
                let video = el.querySelector('video');
                if (!video) {
                    video = document.createElement('video');
                    video.style.width = '100%';
                    video.style.height = '100%';
                    el.appendChild(video);
                }
                if (!video.src || video.src !== elData.content.url) {
                    video.src = elData.content.url || '';
                }
                video.autoplay = !!elData.content.autoplay;
                video.loop = !!elData.content.loop;
                video.controls = elData.content.controls !== false;
                video.playsInline = true;
            },

            _createDOMForChart(el, elData) {
                const canvasEl = document.createElement('canvas');
                canvasEl.id = `chart-${elData.id}`;
                canvasEl.style.width = '100%';
                canvasEl.style.height = '100%';
                el.appendChild(canvasEl);
                setTimeout(() => {
                    if (canvasEl) {
                        new Chart(canvasEl.getContext('2d'), elData.content);
                    }
                }, 0);
            },

            _createDOMForTable(el, elData) {
                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.height = '100%';
                table.style.borderCollapse = 'collapse';
                for (let r = 0; r < elData.content.rows; r++) {
                    const tr = document.createElement('tr');
                    for (let c = 0; c < elData.content.cols; c++) {
                        const td = document.createElement('td');
                        td.textContent = elData.content.data?.[r]?.[c] ?? '';
                        td.style.border = '1px solid #888';
                        td.style.padding = '4px';
                        tr.appendChild(td);
                    }
                    table.appendChild(tr);
                }
                el.appendChild(table);
            },

            _createDOMForIcon(el, elData) {
                if (elData.iconType === 'fa') {
                    const iTag = document.createElement('i');
                    iTag.className = elData.content;
                    iTag.style.color = elData.style.color || 'inherit';
                    iTag.style.fontSize = elData.style.fontSize ? `${elData.style.fontSize}px` : 'inherit';
                    iTag.style.position = 'absolute';
                    iTag.style.left = '50%';
                    iTag.style.top = '50%';
                    iTag.style.transform = 'translate(-50%, -50%)';
                    el.style.overflow = 'visible';
                    el.appendChild(iTag);
                } else if (elData.iconType === 'mi') {
                    const spanTag = document.createElement('span');
                    spanTag.className = elData.content;
                    spanTag.textContent = elData.miContent;
                    spanTag.style.color = elData.style.color || 'inherit';
                    spanTag.style.fontSize = elData.style.fontSize ? `${elData.style.fontSize}px` : 'inherit';
                    spanTag.style.position = 'absolute';
                    spanTag.style.left = '50%';
                    spanTag.style.top = '50%';
                    spanTag.style.transform = 'translate(-50%, -50%)';
                    el.style.overflow = 'visible';
                    el.appendChild(spanTag);
                }
            },

            _createDOMForIframe(el, elData) {
                const iframe = document.createElement('iframe');
                iframe.src = elData.content.url;
                iframe.style.width = '100%';
                iframe.style.height = '100%';
                iframe.style.border = 'none';
                iframe.sandbox = elData.content.sandbox || 'allow-scripts allow-same-origin';
                el.appendChild(iframe);

                const overlay = document.createElement('div');
                overlay.className = 'iframe-overlay';
                Object.assign(overlay.style, {
                    position: 'absolute',
                    top: 0, left: 0, right: 0, bottom: 0,
                    zIndex: 10000,
                    backgroundColor: 'transparent',
                    cursor: 'move',
                });
                overlay.addEventListener('mousedown', (e) => {
                    App.handleCanvasMouseDown(e);
                });
                overlay.addEventListener('touchstart', (e) => {
                    App.handleCanvasMouseDown(e);
                }, { passive: false });
                el.appendChild(overlay);
            },

            applyStyles(element, styles) {
                // StyleManagerに委譲
                StyleManager.applyStyles(element, styles);
            },

            addResizeHandles(element) {
                // StyleManagerに委譲
                StyleManager.addResizeHandles(element);
            },

            renderInspector() {
                const selectedElement = this.state.selectedElementIds.length === 1 ? this.getSelectedElement() : null;
                const inspectorTabActive = this.elements.sidebarTabs.querySelector('[data-tab="inspector"]')?.classList.contains('active');

                if (selectedElement && inspectorTabActive) {
                    this.elements.inspector.style.display = 'block';
                    this.elements.noSelectionMessage.style.display = 'none';
                    this.elements.sidebarContent.style.display = 'block';
                    this.elements.leftSidebar.style.width = '340px';

                    const s = selectedElement.style;
                    const customCss = s.customCss || '';
                    let chartUI = '';
                    let videoUI = '';
                    let tableUI = '';

                    // 表要素用UI
                    if (selectedElement.type === 'table') {
                        const t = selectedElement.content;
                        let rowsInputs = '';
                        for (let r = 0; r < t.rows; r++) {
                            let row = '<tr>';
                            for (let c = 0; c < t.cols; c++) {
                                const val = t.data?.[r]?.[c] ?? '';
                                row += `<td><input type="text" data-table-row="${r}" data-table-col="${c}" value="${val}" style="width:60px;"></td>`;
                            }
                            row += '</tr>';
                            rowsInputs += row;
                        }
                        tableUI = `
                            <div class="inspector-group">
                                <label>行数 <input type="number" id="table-rows" value="${t.rows}" min="1" max="20" style="width:50px;"></label>
                                <label>列数 <input type="number" id="table-cols" value="${t.cols}" min="1" max="20" style="width:50px;"></label>
                            </div>
                            <div class="inspector-group">
                                <label>セル内容</label>
                                <table style="border-collapse:collapse;">${rowsInputs}</table>
                            </div>
                            <button id="update-table-btn" style="margin-top:10px;width:100%;padding:8px;">表を更新</button>
                        `;
                    }

                    // グラフ要素用UI
                    if (selectedElement.type === 'chart') {
                        const chartData = selectedElement.content.data;
                        chartUI = `
                            <div class="inspector-group">
                                <label>グラフデータ編集</label>
                                <div style="margin-top: 10px;">
                                    <label>データセット名</label>
                                    <input type="text" id="chart-dataset-label" value="${chartData.datasets[0].label}" style="width: 100%;">
                                </div>
                                <div style="margin-top: 10px;">
                                    <label>ラベル (カンマ区切り)</label>
                                    <input type="text" id="chart-labels" value="${chartData.labels.join(',')}" style="width: 100%;">
                                </div>
                                <div style="margin-top: 10px;">
                                    <label>値 (カンマ区切り)</label>
                                    <input type="text" id="chart-data" value="${chartData.datasets[0].data.join(',')}" style="width: 100%;">
                                </div>
                                <button id="update-chart-btn" style="margin-top: 10px; width: 100%; padding: 8px;">グラフを更新</button>
                            </div>`;
                    }

                    // 動画要素用UI
                    if (selectedElement.type === 'video') {
                        const v = selectedElement.content;
                        videoUI = `
                            <div class="inspector-group">
                                <label>動画URL</label>
                                <input type="text" id="video-url" value="${v.url || ''}" style="width:100%;">
                            </div>
                            <div class="inspector-group">
                                <label><input type="checkbox" id="video-autoplay" ${v.autoplay ? 'checked' : ''}> 自動再生</label>
                            </div>
                            <div class="inspector-group">
                                <label><input type="checkbox" id="video-loop" ${v.loop ? 'checked' : ''}> ループ再生</label>
                            </div>
                            <div class="inspector-group">
                                <label><input type="checkbox" id="video-controls" ${v.controls !== false ? 'checked' : ''}> コントロール表示</label>
                            </div>
                            <button id="update-video-btn" style="margin-top:10px;width:100%;padding:8px;">動画設定を反映</button>
                        `;
                    }

                    this.elements.inspector.innerHTML = `
                        <div class="inspector-group"><label>位置 & サイズ</label><div class="pos-size-grid">
                            <div><label>X (%)<input type="number" data-prop="left" value="${s.left.toFixed(2)}" step="0.1"></label></div>
                            <div><label>Y (%)<input type="number" data-prop="top" value="${s.top.toFixed(2)}" step="0.1"></label></div>
                            <div><label>幅 (%)<input type="number" data-prop="width" value="${s.width.toFixed(2)}" step="0.1"></label></div>
                            <div><label>高さ (%)<input type="number" data-prop="height" value="${(s.height || 0).toFixed(2)}" step="0.1" ${selectedElement.type !== 'image' && selectedElement.type !== 'video' ? 'disabled' : ''}></label></div>
                        </div></div>
                        <div class="inspector-group"><label>回転 (deg)</label><input type="number" data-prop="rotation" value="${s.rotation || 0}" step="1"></div>
                        <div class="inspector-group"><label>重ね順</label><input type="number" data-prop="zIndex" value="${s.zIndex}"></div>
                        <div class="inspector-group">
                            <label>アニメーション</label>
                            <select data-prop="animation">
                                <option value="">なし</option>
                                <option value="animate__bounce" ${s.animation === 'animate__bounce' ? 'selected' : ''}>バウンス</option>
                                <option value="animate__fadeIn" ${s.animation === 'animate__fadeIn' ? 'selected' : ''}>フェードイン</option>
                                <option value="animate__zoomIn" ${s.animation === 'animate__zoomIn' ? 'selected' : ''}>ズームイン</option>
                                <option value="animate__slideInLeft" ${s.animation === 'animate__slideInLeft' ? 'selected' : ''}>左からスライド</option>
                                <option value="animate__slideInRight" ${s.animation === 'animate__slideInRight' ? 'selected' : ''}>右からスライド</option>
                            </select>
                        </div>
${selectedElement.type === 'text' ? `
                        <div class="inspector-group">
                            <label><input type="checkbox" data-prop="vertical" id="vertical-writing-checkbox" ${s.vertical ? 'checked' : ''}> 縦書き</label>
                        </div>
                        <div class="inspector-group"><label>フォントサイズ (px)</label><input type="number" data-prop="fontSize" value="${s.fontSize || 24}"></div>
                        <div class="inspector-group">
                            <label>フォント</label>
                            <select data-prop="fontFamily" id="font-family-select">
                                <option style="font-family: sans-serif" value="sans-serif" ${s.fontFamily === 'sans-serif' ? 'selected' : ''}>モダン (Sans-serif)</option>
                                <option style="font-family: serif" value="serif" ${s.fontFamily === 'serif' ? 'selected' : ''}>クラシック (Serif)</option>
                                <option style="font-family: '游ゴシック体', 'YuGothic', 'Yu Gothic', sans-serif" value="游ゴシック体,YuGothic,'Yu Gothic',sans-serif" ${s.fontFamily && s.fontFamily.includes('YuGothic') ? 'selected' : ''}>游ゴシック</option>
                                <option style="font-family: 'メイリオ', 'Meiryo', sans-serif" value="メイリオ,Meiryo,sans-serif" ${s.fontFamily && s.fontFamily.includes('Meiryo') ? 'selected' : ''}>メイリオ</option>
                                <option style="font-family: 'Roboto', sans-serif" value="Roboto, sans-serif" ${s.fontFamily === 'Roboto, sans-serif' ? 'selected' : ''}>Roboto</option>
                                <option style="font-family: 'Montserrat', sans-serif" value="Montserrat, sans-serif" ${s.fontFamily === 'Montserrat, sans-serif' ? 'selected' : ''}>Montserrat</option>
                                <option style="font-family: 'M PLUS Rounded 1c', sans-serif" value="'M PLUS Rounded 1c', sans-serif" ${s.fontFamily === "'M PLUS Rounded 1c', sans-serif" ? 'selected' : ''}>M PLUS Rounded 1c</option>
                                <option style="font-family: 'Sawarabi Mincho', serif" value="'Sawarabi Mincho', serif" ${s.fontFamily === "'Sawarabi Mincho', serif" ? 'selected' : ''}>Sawarabi Mincho</option>
                                <option style="font-family: 'Yuji Syuku', serif" value="'Yuji Syuku', serif" ${s.fontFamily === "'Yuji Syuku', serif" ? 'selected' : ''}>Yuji Syuku</option>
                                <option style="font-family: 'Kaisei Opti', serif" value="'Kaisei Opti', serif" ${s.fontFamily === "'Kaisei Opti', serif" ? 'selected' : ''}>Kaisei Opti</option>
                                <option style="font-family: 'Shippori Mincho', serif" value="'Shippori Mincho', serif" ${s.fontFamily === "'Shippori Mincho', serif" ? 'selected' : ''}>Shippori Mincho</option>
                                <option style="font-family: 'Playfair Display', serif" value="'Playfair Display', serif" ${s.fontFamily === "'Playfair Display', serif" ? 'selected' : ''}>Playfair Display</option>
                                <option style="font-family: 'Lato', sans-serif" value="'Lato', sans-serif" ${s.fontFamily === "'Lato', sans-serif" ? 'selected' : ''}>Lato</option>
                                <option style="font-family: 'Poppins', sans-serif" value="'Poppins', sans-serif" ${s.fontFamily === "'Poppins', sans-serif" ? 'selected' : ''}>Poppins</option>
                            </select>
                            <input type="file" id="font-upload" accept=".ttf,.otf,.woff,.woff2" style="margin-top:8px;">
                            <div id="uploaded-fonts-list" style="margin-top:4px;"></div>
                        </div>
                        <div class="inspector-group"><label>文字色</label><input type="color" data-prop="color" value="${s.color || '#212529'}"></div>
                        ` : ''}
                        ${selectedElement.type === 'icon' ? `
                        <div class="inspector-group">
                            <label>アイコンスタイル</label>
                            ${selectedElement.iconType === 'fa' ? `
                                <select id="icon-style-select" style="width:100%;padding:6px;border-radius:6px;">
                                    <option value="fas" ${selectedElement.content.startsWith('fas ') ? 'selected' : ''}>Solid</option>
                                    <option value="far" ${selectedElement.content.startsWith('far ') ? 'selected' : ''}>Regular</option>
                                    <option value="fal" ${selectedElement.content.startsWith('fal ') ? 'selected' : ''}>Light</option>
                                    <option value="fat" ${selectedElement.content.startsWith('fat ') ? 'selected' : ''}>Thin</option>
                                </select>
                            ` : `
                                <select id="icon-style-select" style="width:100%;padding:6px;border-radius:6px;">
                                    <option value="material-icons" ${selectedElement.content === 'material-icons' ? 'selected' : ''}>Filled</option>
                                    <option value="material-icons-outlined" ${selectedElement.content === 'material-icons-outlined' ? 'selected' : ''}>Outlined</option>
                                    <option value="material-icons-round" ${selectedElement.content === 'material-icons-round' ? 'selected' : ''}>Round</option>
                                    <option value="material-icons-sharp" ${selectedElement.content === 'material-icons-sharp' ? 'selected' : ''}>Sharp</option>
                                    <option value="material-icons-two-tone" ${selectedElement.content === 'material-icons-two-tone' ? 'selected' : ''}>Two Tone</option>
                                </select>
                            `}
                        </div>
                        <div class="inspector-group"><label>アイコンサイズ (px)</label><input type="number" data-prop="fontSize" value="${s.fontSize || 48}"></div>
                        <div class="inspector-group"><label>アイコン色</label><input type="color" data-prop="color" value="${s.color || '#212529'}"></div>
                        ` : ''}
                        ${videoUI}
                        ${chartUI}
                        ${tableUI}
                        ${selectedElement.type === 'iframe' ? `
                        <div class="inspector-group">
                            <label>iframe URL</label>
                            <input type="text" data-prop="url" value="${selectedElement.content.url || ''}" id="iframe-url-input" style="width:100%;">
                        </div>
                        <div class="inspector-group">
                            <label>Sandbox属性 (スペース区切り)</label>
                            <input type="text" data-prop="sandbox" value="${selectedElement.content.sandbox || ''}" id="iframe-sandbox-input" style="width:100%;">
                            <small style="font-size:10px;color:#666;">例: allow-scripts allow-same-origin allow-popups</small>
                        </div>
                        <button id="update-iframe-btn" style="margin-top:10px;width:100%;padding:8px;">埋め込み設定を反映</button>
                        ` : ''}
                        <div class="inspector-group" style="margin-top: 30px;"><button id="delete-element-btn">要素を削除</button></div>
                        <div class="inspector-group">
                            <label>カスタムCSS</label>
                            <div id="element-css-editor-container" style="border: 1px solid var(--border-color); border-radius: var(--border-radius);"></div>
                        </div>
`;
                    this.initElementCssEditor(customCss);
                    document.getElementById('delete-element-btn').onclick = () => this.deleteSelectedElements();

                    // グラフ更新ボタンのイベント追加
                    if (selectedElement.type === 'chart') {
                        document.getElementById('update-chart-btn').onclick = () => {
                            const labels = document.getElementById('chart-labels').value.split(',').map(l => l.trim());
                            const dataValues = document.getElementById('chart-data').value.split(',').map(d => parseFloat(d.trim()) || 0);
                            const datasetLabel = document.getElementById('chart-dataset-label').value;

                            selectedElement.content.data.labels = labels;
                            selectedElement.content.data.datasets[0].label = datasetLabel;
                            selectedElement.content.data.datasets[0].data = dataValues;

                            this.saveState();
                            this.render();
                        };
                    }

                    // iframe設定反映ボタン
                    if (selectedElement.type === 'iframe') {
                        const updateIframeBtn = document.getElementById('update-iframe-btn');
                        if (updateIframeBtn) {
                            updateIframeBtn.onclick = () => {
                                selectedElement.content.url = document.getElementById('iframe-url-input').value;
                                selectedElement.content.sandbox = document.getElementById('iframe-sandbox-input').value;
                                this.saveState();
                                this.render();
                            };
                        }
                    }

                    // 動画設定反映ボタン
                    if (selectedElement.type === 'video') {
                        document.getElementById('update-video-btn').onclick = () => {
                            selectedElement.content.url = document.getElementById('video-url').value;
                            selectedElement.content.autoplay = document.getElementById('video-autoplay').checked;
                            selectedElement.content.loop = document.getElementById('video-loop').checked;
                            selectedElement.content.controls = document.getElementById('video-controls').checked;
                            this.saveState();
                            this.render();
                        };
                    }

                    // 表更新ボタン
                    if (selectedElement.type === 'table') {
                        const updateTableBtn = document.getElementById('update-table-btn');
                        if (updateTableBtn) {
                            updateTableBtn.onclick = () => {
                                const newRows = parseInt(document.getElementById('table-rows').value);
                                const newCols = parseInt(document.getElementById('table-cols').value);

                                // 既存データを保持しながらサイズ変更
                                const currentData = selectedElement.content.data || [];
                                const newData = [];

                                for (let r = 0; r < newRows; r++) {
                                    const row = [];
                                    for (let c = 0; c < newCols; c++) {
                                        // セル入力フィールドから値を取得、存在しない場合は既存データまたは空文字
                                        const input = document.querySelector(`input[data-table-row="${r}"][data-table-col="${c}"]`);
                                        if (input) {
                                            row.push(input.value);
                                        } else {
                                            row.push(currentData[r]?.[c] || '');
                                        }
                                    }
                                    newData.push(row);
                                }

                                selectedElement.content.rows = newRows;
                                selectedElement.content.cols = newCols;
                                selectedElement.content.data = newData;
                                if (window.developmentMode) {
                                    console.log("Table updated:", JSON.parse(JSON.stringify(selectedElement.content))); // Debug
                                }

                                this.saveState();
                                this.render();
                            };
                        }
                    }

                    // --- カスタムフォントアップロード機能 ---
                    if (selectedElement && selectedElement.type === 'text') {
                        window._customFonts = window._customFonts || [];
                        const fontSelect = document.getElementById('font-family-select');
                        const fontsListDiv = document.getElementById('uploaded-fonts-list');
                        window._customFonts.forEach(f => {
                            if (!fontSelect.querySelector(`option[value="${f.family}"]`)) {
                                const opt = document.createElement('option');
                                opt.value = f.family;
                                opt.textContent = f.family + ' (アップロード)';
                                if (s.fontFamily === f.family) opt.selected = true;
                                fontSelect.appendChild(opt);
                            }
                        });
                        fontsListDiv.innerHTML = window._customFonts.map(f => `<span style="font-family:'${f.family}';font-size:14px;">${f.family}</span>`).join('<br>');
                        document.getElementById('font-upload').addEventListener('change', function (e) {
                            const file = e.target.files[0];
                            if (!file) return;
                            const reader = new FileReader();
                            reader.onload = function (ev) {
                                const fontFamily = file.name.replace(/\.[^/.]+$/, '').replace(/[^a-zA-Z0-9_\-]/g, '_');
                                const style = document.createElement('style');
                                style.innerHTML = `
                                        @font-face {
                                            font-family: '${fontFamily}';
                                            src: url('${ev.target.result}');
                                        }
                                    `;
                                document.head.appendChild(style);
                                window._customFonts.push({ family: fontFamily, data: ev.target.result });
                                const opt = document.createElement('option');
                                opt.value = fontFamily;
                                opt.textContent = fontFamily + ' (アップロード)';
                                fontSelect.appendChild(opt);
                                fontSelect.value = fontFamily;
                                s.fontFamily = fontFamily;
                                App.saveState();
                                App.render();
                            };
                            reader.readAsDataURL(file);
                        });
                        if (window._customFonts.length > 0) {
                            fontsListDiv.innerHTML += '<div style="color:#dc3545;font-size:12px;">ページ再読込後は再アップロードが必要です</div>';
                        }
                    }
                    // --- アイコンスタイル切り替え ---
                    if (selectedElement && selectedElement.type === 'icon') {
                        const styleSelect = document.getElementById('icon-style-select');
                        if (styleSelect) {
                            styleSelect.addEventListener('change', function () {
                                App.updateIconStyle(selectedElement, this.value);
                            });
                        }
                    }
                } else {
                    this.elements.inspector.style.display = 'none';
                    this.elements.noSelectionMessage.style.display = 'block';
                    // If inspector tab is active but nothing is selected, hide the content panel
                    if (inspectorTabActive) {
                        this.elements.sidebarContent.style.display = 'none';
                        this.elements.leftSidebar.style.width = '60px';
                    }
                }
            },

            bindEvents() {
                this.elements.addSlideBtn.addEventListener('click', () => this.addSlide());
                this.elements.deleteSlideBtn.addEventListener('click', () => this.deleteSlide());
                this.elements.addTextBtn.addEventListener('click', () => this.addElement('text'));

                // QRコードボタン
                const qrBtn = document.getElementById('add-qr-btn');
                if (qrBtn) {
                    qrBtn.addEventListener('click', function () {
                        if (typeof MicroModal !== "undefined") {
                            MicroModal.show('qr-modal');
                        }
                        // 初期化
                        document.getElementById('qr-text').value = '';
                        document.getElementById('qr-size').value = 256;
                        document.getElementById('qr-preview').innerHTML = '';
                    });
                }

                // Image upload button
                this.elements.addImageBtn.addEventListener('click', () => {
                    this.elements.imageUploadInput.click(); // Trigger hidden file input
                });
                // Handle file selection for image upload
                this.elements.imageUploadInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file && file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            this.addElement('image', e.target.result); // Pass Base64 data URL
                        };
                        reader.readAsDataURL(file);
                    }
                    event.target.value = null; // Reset file input
                });

                this.elements.addVideoBtn = document.getElementById('add-video-btn');
                this.elements.addVideoBtn.addEventListener('click', () => this.addElement('video'));
                this.elements.addTableBtn = document.getElementById('add-table-btn');
                this.elements.addTableBtn.addEventListener('click', () => this.addElement('table'));
                this.elements.addChartBtn.addEventListener('click', () => this.addChart());
                this.elements.addIframeBtn.addEventListener('click', () => this.addElement('iframe'));
                this.elements.saveBtn.addEventListener('click', () => this.saveState());
                this.elements.presentBtn.addEventListener('click', () => this.startPresentation());
                this.elements.exportBtn.addEventListener('click', (e) => this.showExportMenu(e));

                // 旧右ペインタブ切り替え (これは新しいサイドバータブに置き換わる)
                // document.querySelectorAll('.tab-button').forEach(button => { ... });

                // New sidebar tab switching logic
                if (this.elements.sidebarTabs) {
                    this.elements.sidebarTabs.addEventListener('click', e => {
                        const button = e.target.closest('.sidebar-tab-button');
                        if (button) {
                            const tabName = button.dataset.tab;
                            this.switchToTab(tabName);
                        }
                    });
                }

                // Font Awesomeの検索とスタイル選択
                // アイコン切り替えボタンのイベントリスナー
                const faToggleButton = document.getElementById('fa-toggle-btn');
                const miToggleButton = document.getElementById('mi-toggle-btn');
                const fontAwesomeSection = document.getElementById('font-awesome-section');
                const materialIconsSection = document.getElementById('material-icons-section');

                if (faToggleButton && miToggleButton && fontAwesomeSection && materialIconsSection) {
                    faToggleButton.addEventListener('click', () => {
                        faToggleButton.classList.add('active');
                        miToggleButton.classList.remove('active');
                        fontAwesomeSection.style.display = 'block';
                        materialIconsSection.style.display = 'none';
                        this.initCategoryFilters('fa');
                        this.renderIconList('fa');
                    });

                    miToggleButton.addEventListener('click', () => {
                        miToggleButton.classList.add('active');
                        faToggleButton.classList.remove('active');
                        materialIconsSection.style.display = 'block';
                        fontAwesomeSection.style.display = 'none';
                        this.initCategoryFilters('mi');
                        this.renderIconList('mi');
                    });
                }

                // Font Awesomeの検索とスタイル選択
                if (this.elements.faIconSearchInput) {
                    this.elements.faIconSearchInput.addEventListener('input', e => {
                        const activeCategoryButton = this.elements.faIconCategoryFilter.querySelector('button.active');
                        const category = activeCategoryButton ? activeCategoryButton.dataset.category : 'すべて';
                        this.renderIconList('fa', e.target.value, category);
                    });
                }
                const faStyleSelect = document.getElementById('fa-style-select');
                if (faStyleSelect) {
                    faStyleSelect.addEventListener('change', () => {
                        const activeCategoryButton = this.elements.faIconCategoryFilter.querySelector('button.active');
                        const category = activeCategoryButton ? activeCategoryButton.dataset.category : 'すべて';
                        this.renderIconList('fa', this.elements.faIconSearchInput.value, category);
                    });
                }
                if (this.elements.faIconCategoryFilter) {
                    this.initCategoryFilters('fa');
                }
                if (this.elements.faIconListContainer) {
                    this.elements.faIconListContainer.addEventListener('click', e => {
                        const iconDiv = e.target.closest('.icon-item');
                        if (iconDiv && iconDiv.dataset.iconClass) {
                            this.addIconElement('fa', iconDiv.dataset.iconClass);
                        }
                    });
                }

                // Material Iconsの検索とスタイル選択
                if (this.elements.miIconSearchInput) {
                    this.elements.miIconSearchInput.addEventListener('input', e => {
                        const activeCategoryButton = this.elements.miIconCategoryFilter.querySelector('button.active');
                        const category = activeCategoryButton ? activeCategoryButton.dataset.category : 'すべて';
                        this.renderIconList('mi', e.target.value, category);
                    });
                }
                const miStyleSelect = document.getElementById('mi-style-select');
                if (miStyleSelect) {
                    miStyleSelect.addEventListener('change', () => {
                        const activeCategoryButton = this.elements.miIconCategoryFilter.querySelector('button.active');
                        const category = activeCategoryButton ? activeCategoryButton.dataset.category : 'すべて';
                        this.renderIconList('mi', this.elements.miIconSearchInput.value, category);
                    });
                }
                if (this.elements.miIconCategoryFilter) {
                    this.initCategoryFilters('mi');
                }
                if (this.elements.miIconListContainer) {
                    this.elements.miIconListContainer.addEventListener('click', e => {
                        const iconDiv = e.target.closest('.icon-item');
                        if (iconDiv && iconDiv.dataset.iconClass) {
                            this.addIconElement('mi', iconDiv.dataset.iconClass);
                        }
                    });
                }

                // inspector内のselect, input[type="color"]要素のイベント伝播を止める
                this.elements.inspector.addEventListener('mousedown', e => {
                    if (e.target.closest('select, option, input[type="color"]')) e.stopPropagation();
                });
                this.elements.inspector.addEventListener('mouseup', e => {
                    if (e.target.closest('select, option, input[type="color"]')) e.stopPropagation();
                });
                this.elements.inspector.addEventListener('click', e => {
                    if (e.target.closest('select, option, input[type="color"]')) e.stopPropagation();
                });

                // チャット送信
                // チャット送信
                document.getElementById('send-chat-btn').addEventListener('click', async () => {
                    const input = document.getElementById('chat-input');
                    const message = input.value.trim();
                    if (!message) return;

                    const messagesDiv = document.getElementById('chat-messages');

                    // ユーザーのメッセージを表示
                    const userMsgDiv = document.createElement('div');
                    userMsgDiv.className = 'user-msg';
                    userMsgDiv.textContent = `ユーザー: ${message}`;
                    messagesDiv.appendChild(userMsgDiv);
                    input.value = '';
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;

                    // ローディング表示
                    const loadingMsgDiv = document.createElement('div');
                    loadingMsgDiv.className = 'ai-msg';
                    loadingMsgDiv.innerHTML = '<div>AIがコマンドを生成中...</div>';
                    messagesDiv.appendChild(loadingMsgDiv);
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;

                    // AIに問い合わせ
                    const aiXmlCommand = await this.aiHandler.askAI(message);

                    // ローディング表示を削除
                    messagesDiv.removeChild(loadingMsgDiv);

                    // AIからの応答を表示
                    const aiMsgDiv = document.createElement('div');
                    aiMsgDiv.className = 'ai-msg';

                    const aiLabel = document.createElement('div');
                    aiLabel.textContent = 'AIアシスタント:';
                    aiMsgDiv.appendChild(aiLabel);

                    const pre = document.createElement('pre');
                    pre.textContent = aiXmlCommand;
                    aiMsgDiv.appendChild(pre);

                    // エラーでなければ実行ボタンを追加
                    if (!aiXmlCommand.startsWith('<error>')) {
                        const executeBtn = document.createElement('button');
                        executeBtn.className = 'execute-btn';
                        executeBtn.textContent = 'コマンドを実行';
                        executeBtn.dataset.command = aiXmlCommand;
                        aiMsgDiv.appendChild(executeBtn);

                        const resultDiv = document.createElement('div');
                        resultDiv.style.display = 'none'; // 最初は非表示
                        aiMsgDiv.appendChild(resultDiv);
                    }

                    messagesDiv.appendChild(aiMsgDiv);
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                });
                // コマンド実行
                document.getElementById('chat-messages').addEventListener('click', async (e) => {
                    if (e.target.classList.contains('execute-btn')) {
                        // 実行前にチェックポイントを作成
                        this.createAICheckpoint();

                        const commandText = e.target.dataset.command;
                        const resultContainer = e.target.nextElementSibling;
                        try {
                            const result = await this.aiHandler.executeCommand(commandText);
                            if (result.success) {
                                resultContainer.className = 'success-msg';
                                let message = result.message || 'コマンドが正常に実行されました。';
                                if (result.slide) {
                                    // view_slideの結果を整形して表示
                                    const formattedJson = JSON.stringify(result.slide, null, 2);
                                    message = `スライド(ID: ${result.slide.id})の内容:\n<pre>${formattedJson.replace(/</g, '<')}</pre>`;
                                }
                                resultContainer.innerHTML = `✅ 成功: ${message}`;
                            } else {
                                resultContainer.className = 'error-msg';
                                resultContainer.innerHTML = `❌ 失敗: ${result.message}`;
                            }
                        } catch (error) {
                            resultContainer.className = 'error-msg';
                            resultContainer.innerHTML = `❌ エラー: ${error.message}`;
                        }
                        resultContainer.style.display = 'block';
                        e.target.style.display = 'none'; // ボタンを隠す
                    }
                });

                this.elements.restoreCheckpointBtn.addEventListener('click', () => this.restoreAICheckpoint());
                this.elements.autonomousModeToggle.addEventListener('change', (e) => {
                    if (e.target.checked) {
                        this.startAutonomousMode();
                    } else {
                        this.stopAutonomousMode();
                    }
                });
                Object.entries({
                    'alignLeftBtn': () => this.alignElements('left'), 'alignCenterHBtn': () => this.alignElements('center-h'), 'alignRightBtn': () => this.alignElements('right'),
                    'alignTopBtn': () => this.alignElements('top'), 'alignCenterVBtn': () => this.alignElements('center-v'), 'alignBottomBtn': () => this.alignElements('bottom'),
                    'distributeHBtn': () => this.distributeElements('horizontal'), 'distributeVBtn': () => this.distributeElements('vertical'),
                }).forEach(([id, handler]) => this.elements[id].addEventListener('click', handler));

                this.elements.slideList.addEventListener('click', e => this.handleThumbnailClick(e));
                // マウス・タッチ両対応
                const pointerDownHandler = e => {
                    // e.target が存在し、かつ select/option 内でなければ処理を続ける
                    if (!e.target || e.target.closest('select, option')) {
                        return;
                    }

                    const isTouch = e.type.startsWith('touch');
                    // touches が存在するか、または touches[0] が存在するかを確認
                    if (isTouch && (!e.touches || e.touches.length === 0)) {
                        console.error("pointerDownHandler: touch event with no touches.", e);
                        return;
                    }
                    const point = isTouch ? e.touches[0] : e;

                    // point や point.target が存在するかを再度確認
                    if (!point || !point.target) {
                        console.error("pointerDownHandler: point or point.target is undefined after touch check.", e, point);
                        return;
                    }

                    const element = point.target.closest('.slide-element');

                    if (element) {
                        this.handleCanvasMouseDown(e); // 元のイベントオブジェクト e をそのまま渡す
                    } else {
                        this.handleSelectionBoxStart(e); // 元のイベントオブジェクト e をそのまま渡す
                    }
                };
                this.elements.slideCanvas.addEventListener('mousedown', pointerDownHandler);
                this.elements.slideCanvas.addEventListener('touchstart', pointerDownHandler, { passive: false });

                this.elements.slideCanvas.addEventListener('dblclick', e => this.handleCanvasDblClick(e));
                this.elements.slideCanvas.addEventListener('touchend', e => {
                    // タッチでダブルタップ検出
                    if (!this._lastTap) {
                        this._lastTap = Date.now();
                        setTimeout(() => { this._lastTap = null; }, 400);
                    } else {
                        const now = Date.now();
                        if (now - this._lastTap < 400) {
                            const touch = e.changedTouches[0];
                            const target = document.elementFromPoint(touch.clientX, touch.clientY);
                            if (target && target.classList.contains('slide-element') && target.classList.contains('text')) {
                                this.handleCanvasDblClick({ target });
                            }
                        }
                        this._lastTap = null;
                    }
                });
                this.elements.slideCanvas.addEventListener('blur', e => this.handleElementBlur(e), true);
                this.elements.inspector.addEventListener('input', e => this.handleInspectorInput(e));

                // ページCSS保存ボタン
                const saveGlobalCssBtn = document.getElementById('save-global-css-btn');
                if (saveGlobalCssBtn) {
                    saveGlobalCssBtn.addEventListener('click', () => {
                        if (this.cmInstances.globalCssEditor) {
                            const css = this.cmInstances.globalCssEditor.state.doc.toString();
                            this.state.presentation.settings.globalCss = css;
                            this.applyCustomCss();
                            this.saveState();
                            alert('ページ全体のCSSを適用しました。');
                        }
                    });
                }

                this.elements.slideCanvas.addEventListener('contextmenu', e => {
                    e.preventDefault();
                    const el = e.target.closest('.slide-element');
                    // 複数選択中なら空白右クリックでも複数用メニュー
                    if (
                        (el && el.dataset.id && !(el.getAttribute('contenteditable') === 'true')) ||
                        (this.state.selectedElementIds && this.state.selectedElementIds.length > 1)
                    ) {
                        // 複数選択時は最初の選択要素IDを渡す
                        const targetId = el?.dataset?.id || this.state.selectedElementIds[0];
                        this.showElementContextMenu(e, targetId);
                    } else {
                        this.showPasteContextMenu(e);
                    }
                });
                window.addEventListener('mousemove', e => this.handleMouseMove(e));
                window.addEventListener('touchmove', e => this.handleMouseMove(e), { passive: false });
                window.addEventListener('mouseup', e => this.handleMouseUp(e));
                window.addEventListener('touchend', e => this.handleMouseUp(e));
                window.addEventListener('keydown', e => this.handleKeyDown(e));
                window.addEventListener('keyup', e => this.handleKeyUp(e));
                window.addEventListener('resize', () => this.render());
                document.addEventListener('fullscreenchange', () => { if (!document.fullscreenElement) this.stopPresentation(); });
            },

            // スライド拡大縮小コントロール初期化
            initZoomControl() {
                // タッチデバイス向け: 2本指パン・ピンチズーム
                let lastTouchDist = null;
                let lastTouchCenter = null;
                this.elements.slideCanvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        const t1 = e.touches[0], t2 = e.touches[1];
                        lastTouchDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                        lastTouchCenter = {
                            x: (t1.clientX + t2.clientX) / 2,
                            y: (t1.clientY + t2.clientY) / 2
                        };
                        if (!this.state.canvasPan) {
                            this.state.canvasPan = { x: 0, y: 0, dragging: false, startX: 0, startY: 0, originX: 0, originY: 0 };
                        }
                        this.state.canvasPan.dragging = true;
                        this.state.canvasPan.startX = lastTouchCenter.x;
                        this.state.canvasPan.startY = lastTouchCenter.y;
                        this.state.canvasPan.originX = this.state.canvasPan.x;
                        this.state.canvasPan.originY = this.state.canvasPan.y;
                    }
                }, { passive: false });
                this.elements.slideCanvas.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2 && this.state.canvasPan && this.state.canvasPan.dragging) {
                        e.preventDefault();
                        const t1 = e.touches[0], t2 = e.touches[1];
                        const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                        const center = {
                            x: (t1.clientX + t2.clientX) / 2,
                            y: (t1.clientY + t2.clientY) / 2
                        };
                        // ピンチズーム
                        if (lastTouchDist) {
                            let scale = this.state.canvasScale * (dist / lastTouchDist);
                            scale = Math.max(0.2, Math.min(5, scale));
                            this.state.canvasScale = scale;
                            this.updateZoomDisplay();
                        }
                        // 2本指パン
                        if (lastTouchCenter) {
                            const dx = center.x - this.state.canvasPan.startX;
                            const dy = center.y - this.state.canvasPan.startY;
                            this.state.canvasPan.x = this.state.canvasPan.originX + dx;
                            this.state.canvasPan.y = this.state.canvasPan.originY + dy;
                        }
                        lastTouchDist = dist;
                        lastTouchCenter = center;
                        this.render();
                    }
                }, { passive: false });
                this.elements.slideCanvas.addEventListener('touchend', (e) => {
                    if (this.state.canvasPan && this.state.canvasPan.dragging) {
                        this.state.canvasPan.dragging = false;
                        lastTouchDist = null;
                        lastTouchCenter = null;
                    }
                });
                // ミドルクリックパン
                const canvas = this.elements.slideCanvas;
                canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 1) {
                        e.preventDefault();
                        if (!this.state.canvasPan) {
                            this.state.canvasPan = { x: 0, y: 0, dragging: false, startX: 0, startY: 0, originX: 0, originY: 0 };
                        }
                        this.state.canvasPan.dragging = true;
                        this.state.canvasPan.startX = e.clientX;
                        this.state.canvasPan.startY = e.clientY;
                        this.state.canvasPan.originX = this.state.canvasPan.x;
                        this.state.canvasPan.originY = this.state.canvasPan.y;
                        document.body.style.cursor = 'grab';
                    }
                });
                window.addEventListener('mousemove', (e) => {
                    if (this.state.canvasPan && this.state.canvasPan.dragging) {
                        const dx = e.clientX - this.state.canvasPan.startX;
                        const dy = e.clientY - this.state.canvasPan.startY;
                        this.state.canvasPan.x = this.state.canvasPan.originX + dx;
                        this.state.canvasPan.y = this.state.canvasPan.originY + dy;
                        this.render();
                    }
                });
                window.addEventListener('mouseup', (e) => {
                    if (this.state.canvasPan && this.state.canvasPan.dragging) {
                        this.state.canvasPan.dragging = false;
                        document.body.style.cursor = '';
                    }
                });
                // ホイールで拡大縮小 (Ctrlキー不要)
                this.elements.slideCanvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    let scale = this.state.canvasScale;
                    if (e.deltaY < 0) scale *= 1.1;
                    else scale /= 1.1;
                    scale = Math.max(0.2, Math.min(5, scale));
                    this.state.canvasScale = scale;
                    this.render();
                    this.updateZoomDisplay();
                }, { passive: false });
                // ズームリセットボタン
                if (!document.getElementById('zoom-reset-btn')) {
                    const btn = document.createElement('button');
                    btn.id = 'zoom-reset-btn';
                    btn.textContent = 'リセット';
                    btn.style.position = 'absolute';
                    btn.style.right = '24px';
                    btn.style.top = '24px';
                    btn.style.zIndex = 10001;
                    btn.style.background = '#fff';
                    btn.style.border = '1px solid #ccc';
                    btn.style.borderRadius = '6px';
                    btn.style.padding = '4px 10px';
                    btn.style.fontSize = '13px';
                    btn.style.cursor = 'pointer';
                    btn.onclick = () => {
                        this.state.canvasScale = 1.0;
                        this.render();
                        this.updateZoomDisplay();
                        // パンもリセット
                        this.state.canvasPan.x = 0;
                        this.state.canvasPan.y = 0;
                    };
                    this.elements.mainCanvasArea.appendChild(btn);
                }
                // ズーム倍率表示
                if (!document.getElementById('zoom-display')) {
                    const disp = document.createElement('div');
                    disp.id = 'zoom-display';
                    disp.style.position = 'absolute';
                    disp.style.right = '24px';
                    disp.style.top = '60px';
                    disp.style.zIndex = 10001;
                    disp.style.background = '#fff';
                    disp.style.border = '1px solid #ccc';
                    disp.style.borderRadius = '6px';
                    disp.style.padding = '2px 10px';
                    disp.style.fontSize = '13px';
                    this.elements.mainCanvasArea.appendChild(disp);
                }
                this.updateZoomDisplay();
            },
            updateZoomDisplay() {
                const disp = document.getElementById('zoom-display');
                if (disp) {
                    disp.textContent = `ズーム: ${(this.state.canvasScale * 100).toFixed(0)}%`;
                }
            },

            handleCanvasMouseDown(e) {
                const isTouch = e.type.startsWith('touch');
                const point = isTouch ? e.touches[0] : e;
                let target = point.target;

                // Traverse up to find an Element if the target is not one (e.g., a text node)
                while (target && target.nodeType !== Node.ELEMENT_NODE) {
                    target = target.parentNode;
                }

                if (!target || typeof target.closest !== 'function') {
                    console.error("handleCanvasMouseDown: target is not an Element or is null.", point.target, e);
                    return;
                }

                const element = target.closest('.slide-element');
                const elementId = element ? element.dataset.id : null;
                this.state.interaction.isCtrlPressed = e.ctrlKey || e.metaKey;

                if (this.state.isEditingText) {
                    // 編集中に現在の編集要素以外をクリックした場合は編集を終了
                    if (!elementId || !this.state.selectedElementIds.includes(elementId)) {
                        this.stopTextEditing(true);
                    }
                    return;
                }

                // 複数選択時のドラッグ開始を直感的に
                if (elementId) {
                    if (this.state.selectedElementIds.includes(elementId)) {
                        // 既に選択中の要素上なら選択状態維持してドラッグ開始
                        // e.preventDefault() を削除。実際の移動が始まるMouseMove/TouchMoveで呼ぶ
                        if (target.classList.contains('resize-handle')) {
                            this.state.interaction.isResizing = true;
                            this.state.interaction.handle = target.dataset.handle;
                        } else {
                            this.state.interaction.isDragging = true;
                        }
                        this.startInteraction(e);
                        this.render();
                        return;
                    } else {
                        // 未選択要素なら選択を切り替えてからドラッグ開始
                        this.state.selectedElementIds = [elementId];
                        this.render();
                        // 次のmousedownでドラッグ開始
                        return;
                    }
                } else {
                    // キャンバス空白クリックで選択解除
                    this.state.selectedElementIds = [];
                    this.render();
                }
            },

            startInteraction(e) {
                const isTouch = e.type.startsWith('touch');
                const point = isTouch ? e.touches[0] : e;
                this.state.slideCanvasRect = this.elements.slideCanvas.getBoundingClientRect();
                this.state.interaction.startX = point.clientX;
                this.state.interaction.startY = point.clientY;

                this.state.interaction.initialStates = this.getSelectedElementsData().map(elData => {
                    const domEl = this.elements.slideCanvas.querySelector(`[data-id="${elData.id}"]`);
                    return {
                        id: elData.id, startX: elData.style.left, startY: elData.style.top,
                        startW: elData.style.width, startH: elData.style.height ?? (domEl.offsetHeight / this.state.slideCanvasRect.height * 100),
                        initialRect: { left: domEl.offsetLeft, top: domEl.offsetTop, width: domEl.offsetWidth, height: domEl.offsetHeight }
                    };
                });
            },

            handleMouseMove(e) {
                if (!this.state.interaction.isDragging && !this.state.interaction.isResizing) return;
                // passive:false でリスナーを登録しているので、preventDefaultは常に安全
                e.preventDefault();

                const isTouch = e.type.startsWith('touch');
                // touchmoveイベントでtouchesがない場合は何もしない
                if (isTouch && e.touches.length === 0) return;
                const point = isTouch ? e.touches[0] : e;

                const { slideCanvasRect, interaction } = this.state;
                const dx = point.clientX - interaction.startX;
                const dy = point.clientY - interaction.startY;

                // ドラッグ中にiframeの再読み込みを防ぐ
                this.state.selectedElementIds.forEach(id => {
                    const elData = this.getActiveSlide().elements.find(el => el.id === id);
                    if (elData && elData.type === 'iframe') {
                        const iframeEl = this.elements.slideCanvas.querySelector(`[data-id="${id}"] iframe`);
                        if (iframeEl) {
                            iframeEl.style.pointerEvents = 'none';
                        }
                    }
                });

                if (interaction.isDragging) {
                    this.handleDragMove(dx, dy);
                } else if (interaction.isResizing) {
                    const dxPercent = dx / slideCanvasRect.width * 100;
                    const dyPercent = dy / slideCanvasRect.height * 100;
                    this.performResize(dxPercent, dyPercent);
                }
            },

            handleDragMove(dx, dy) {
                this.guideLineManager.clear();
                const { slideCanvasRect, interaction } = this.state;
                const draggingElementsInitialStates = interaction.initialStates;

                // 1. Calculate collective bounds of moving elements at their current position
                const combinedBounds = draggingElementsInitialStates.reduce((acc, state) => {
                    const currentLeft = state.initialRect.left + dx;
                    const currentTop = state.initialRect.top + dy;
                    acc.left = Math.min(acc.left, currentLeft);
                    acc.top = Math.min(acc.top, currentTop);
                    acc.right = Math.max(acc.right, currentLeft + state.initialRect.width);
                    acc.bottom = Math.max(acc.bottom, currentTop + state.initialRect.height);
                    return acc;
                }, { left: Infinity, top: Infinity, right: -Infinity, bottom: -Infinity });
                combinedBounds.centerX = combinedBounds.left + (combinedBounds.right - combinedBounds.left) / 2;
                combinedBounds.centerY = combinedBounds.top + (combinedBounds.bottom - combinedBounds.top) / 2;

                // 2. Get static elements for snapping
                const staticElementsBounds = this.getActiveSlide().elements
                    .filter(el => !this.state.selectedElementIds.includes(el.id))
                    .map(el => {
                        const domEl = this.elements.slideCanvas.querySelector(`[data-id="${el.id}"]`);
                        const rect = { left: domEl.offsetLeft, top: domEl.offsetTop, width: domEl.offsetWidth, height: domEl.offsetHeight };
                        rect.right = rect.left + rect.width; rect.bottom = rect.top + rect.height;
                        rect.centerX = rect.left + rect.width / 2; rect.centerY = rect.top + rect.height / 2;
                        return rect;
                    });
                const canvasBounds = { left: 0, top: 0, right: slideCanvasRect.width, bottom: slideCanvasRect.height, centerX: slideCanvasRect.width / 2, centerY: slideCanvasRect.height / 2 };

                // 3. Calculate snap offsets and get guides
                const { snapOffset, guides } = this.guideLineManager.calculateSnapGuides(combinedBounds, staticElementsBounds, canvasBounds);

                // 4. Apply new positions with snapping
                const elementsToUpdate = this.getSelectedElementsData();
                draggingElementsInitialStates.forEach(initialState => {
                    const elData = elementsToUpdate.find(el => el.id === initialState.id);
                    if (elData) {
                        // 正しいパーセント計算: 移動量をキャンバスサイズで割って100倍
                        const newLeft = initialState.startX + (dx + snapOffset.x) / slideCanvasRect.width * 100;
                        const newTop = initialState.startY + (dy + snapOffset.y) / slideCanvasRect.height * 100;

                        elData.style.left = parseFloat(newLeft.toFixed(2));
                        elData.style.top = parseFloat(newTop.toFixed(2));

                        // Update DOM directly for immediate feedback
                        const domEl = this.elements.slideCanvas.querySelector(`[data-id="${elData.id}"]`);
                        if (domEl) this.applyStyles(domEl, elData.style);
                    }
                });

                // 5. Render guides and bounding box
                this.renderSelectionBoundingBox();
                guides.forEach(g => { const [o, p] = g.split('-'); this.guideLineManager.addGuide(o, p); });
            },

            handleMouseUp() {
                // テキスト編集中は、ドラッグ/リサイズ状態のみリセットし、再描画しない
                if (this.state.isEditingText) {
                    this.state.interaction.isDragging = false;
                    this.state.interaction.isResizing = false;
                    return;
                }

                if (this.state.interaction.isDragging || this.state.interaction.isResizing) this.saveState();
                this.guideLineManager.clear();
                this.state.interaction.isDragging = false;
                this.state.interaction.isResizing = false;
                this.state.interaction.initialStates = [];

                // ドラッグ終了後、iframeのpointer-eventsを元に戻す
                this.state.selectedElementIds.forEach(id => {
                    const elData = this.getActiveSlide().elements.find(el => el.id === id);
                    if (elData && elData.type === 'iframe') {
                        const iframeEl = this.elements.slideCanvas.querySelector(`[data-id="${id}"] iframe`);
                        if (iframeEl) {
                            iframeEl.style.pointerEvents = 'auto'; // または 'initial'
                        }
                    }
                });

                this.render(); // Final render to clean up handles etc.
            },

            performResize(dx, dy) {
                const { handle, initialStates } = this.state.interaction;
                const elData = this.getSelectedElement();
                const initialState = initialStates[0];
                if (!elData || !initialState) return;

                let { left, top, width, height } = elData.style;
                const { startX, startY, startW, startH } = initialState;

                // リサイズ開始時のfontSizeを保存（初回のみ）
                if (initialState._initialFontSize === undefined) {
                    initialState._initialFontSize = elData.style.fontSize;
                }
                const initialFontSize = initialState._initialFontSize;

                if (handle.includes('e')) width = Math.max(2, startW + dx);
                if (handle.includes('w')) { width = Math.max(2, startW - dx); left = startX + dx; }
                if (handle.includes('s')) height = startH != null ? Math.max(2, startH + dy) : null;
                if (handle.includes('n')) { height = startH != null ? Math.max(2, startH - dy) : null; top = startY + dy; }

                elData.style.left = left; elData.style.top = top;

                // アイコンはアスペクト比を維持
                if (elData.type === 'icon' && startW > 0) {
                    const ratio = startH / startW;
                    if (width !== startW) { // 幅が変わった
                        height = width * ratio;
                    } else if (height !== startH) { // 高さが変わった
                        width = height / ratio;
                    }
                }

                elData.style.width = width;
                if (height != null) elData.style.height = height;

                // テキストまたはアイコン要素の場合、幅に合わせてフォントサイズを調整
                if ((elData.type === 'text' || elData.type === 'icon') && startW > 0 && width !== startW) {
                    const newFontSize = Math.max(8, Math.round(initialFontSize * (width / startW)));
                    elData.style.fontSize = newFontSize;
                }

                // Direct DOM update for smooth resizing
                const domEl = this.elements.slideCanvas.querySelector(`[data-id="${elData.id}"]`);
                if (domEl) { this.applyStyles(domEl, elData.style); this.renderSelectionBoundingBox(); }
            },

            handleKeyDown(e) {
                const target = e.target;
                const isInputFocused = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.closest('.cm-editor');

                // If typing in an input field, do not trigger global shortcuts like 'delete element'.
                if (isInputFocused) {
                    return; // Exit early
                }

                if (e.key === 'Control' || e.key === 'Meta') this.state.interaction.isCtrlPressed = true;

                if (document.body.classList.contains('presentation-mode')) {
                    if (e.key === 'ArrowRight' || e.key === ' ') this.changePresentationSlide(1);
                    else if (e.key === 'ArrowLeft') this.changePresentationSlide(-1);
                    else if (e.key === 'Escape') this.stopPresentation();
                } else {
                    // テキスト編集中はEscapeキーで編集終了のみ許可
                    if (this.state.isEditingText) {
                        if (e.key === 'Escape') {
                            this.stopTextEditing(true);
                            this.render();
                        }
                        return;
                    }
                    // 一括削除
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        if (this.state.selectedElementIds.length > 0) this.deleteSelectedElements();
                    }
                    // 一括コピー
                    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c') {
                        if (this.state.selectedElementIds.length > 0) {
                            e.preventDefault();
                            this.copySelectedElements();
                        }
                    }
                    // 一括貼り付け
                    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'v') {
                        if (this._lastCopiedIds && this._lastCopiedIds.length > 0) {
                            e.preventDefault();
                            this.pasteCopiedElements();
                        }
                    }
                }
            },
            handleKeyUp(e) { if (e.key === 'Control' || e.key === 'Meta') this.state.interaction.isCtrlPressed = false; },

            toggleElementSelection(id) {
                const { selectedElementIds, interaction } = this.state;
                const index = selectedElementIds.indexOf(id);
                if (id === null) { this.state.selectedElementIds = []; }
                else if (interaction.isCtrlPressed) { if (index === -1) selectedElementIds.push(id); else selectedElementIds.splice(index, 1); }
                else { if (index === -1 || selectedElementIds.length > 1) this.state.selectedElementIds = [id]; }
            },

            stopTextEditing(save = false) {
                if (!this.state.isEditingText) return;
                const editableEl = this.elements.slideCanvas.querySelector('[contenteditable="true"]');
                if (editableEl && save) {
                    const elData = this.getSelectedElement();
                    if (elData) elData.content = editableEl.innerText;
                }
                this.state.isEditingText = false;
            },

            handleCanvasDblClick(e) {
                const element = e.target.closest('.slide-element.text');
                if (element) {
                    this.stopTextEditing(true); // 他の編集中テキストがあれば保存して終了

                    this.state.selectedElementIds = [element.dataset.id];
                    this.state.isEditingText = true;

                    // render()を呼ばずに直接DOMを操作して、意図しない状態の上書きを防ぐ
                    // まず、すべての要素のcontenteditableをfalseにリセット
                    this.elements.slideCanvas.querySelectorAll('.slide-element[contenteditable="true"]')
                        .forEach(el => el.setAttribute('contenteditable', 'false'));

                    // 対象の要素だけ contenteditable を true にする
                    element.setAttribute('contenteditable', 'true');
                    element.focus();

                    // テキストを全選択
                    const selection = window.getSelection();
                    const range = document.createRange();
                    range.selectNodeContents(element);
                    selection.removeAllRanges();
                    selection.addRange(range);

                    // 状態を再描画して、フォーカスを確実に当てる
                    this.render();
                    // render後にもう一度focusを試みる
                    setTimeout(() => {
                        const newElement = this.elements.slideCanvas.querySelector(`[data-id="${element.dataset.id}"]`);
                        if (newElement) {
                            newElement.focus();
                        }
                    }, 0);
                }
            },

            handleElementBlur(e) {
                if (this.state.isEditingText && e.target.classList.contains('slide-element')) {
                    this.stopTextEditing(true);
                    this.saveState();
                    this.render();
                }
            },

            addSlide(silent = false) {
                const newId = this.generateId('slide');
                const newSlide = { id: newId, elements: [] };
                const activeIndex = this.state.presentation.slides.findIndex(s => s.id === this.state.activeSlideId);
                const insertionIndex = activeIndex === -1 ? this.state.presentation.slides.length : activeIndex + 1;
                this.state.presentation.slides.splice(insertionIndex, 0, newSlide);
                if (!silent) {
                    this.state.activeSlideId = newId;
                    this.state.selectedElementIds = [];
                    this.render();
                    this.saveState();
                }
                return newId;
            },
            deleteSlide(slideId, silent = false) {
                if (this.state.presentation.slides.length <= 1) {
                    const msg = '最後のスライドは削除できません。';
                    if (!silent) alert(msg);
                    return { success: false, message: msg };
                }
                const targetId = slideId || this.state.activeSlideId;
                if (!silent && !confirm(`スライド(ID: ${targetId})を削除しますか？`)) {
                    return { success: false, message: '削除がキャンセルされました。' };
                }
                const idx = this.state.presentation.slides.findIndex(s => s.id === targetId);
                if (idx === -1) {
                    return { success: false, message: `スライド(ID: ${targetId})が見つかりません。` };
                }
                this.state.presentation.slides.splice(idx, 1);
                if (this.state.activeSlideId === targetId) {
                    this.state.activeSlideId = this.state.presentation.slides[Math.max(0, idx - 1)]?.id;
                }
                if (!silent) {
                    this.state.selectedElementIds = [];
                    this.render();
                    this.saveState();
                }
                return { success: true };
            },
            addElementToSlide(slideId, type, content, style) {
                const slide = this.state.presentation.slides.find(s => s.id === slideId);
                if (!slide) return null;
                const newEl = {
                    id: this.generateId('el'),
                    type,
                    content: content || '',
                    style: {
                        top: 20, left: 20, width: 30, height: null, zIndex: slide.elements.length + 1, rotation: 0, animation: '',
                        ...style
                    }
                };
                if (type === 'text' && !style?.fontSize) newEl.style.fontSize = 24;
                if (type === 'image' && !style?.height) newEl.style.height = 30;

                slide.elements.push(newEl);
                return newEl;
            },
            addElement(type, content) { // This is for user interaction
                const slide = this.getActiveSlide();
                if (!slide) return;
                const newEl = {
                    id: this.generateId('el'),
                    type,
                    style: { top: 20, left: 20, width: 30, height: null, zIndex: slide.elements.length + 1, rotation: 0, animation: '' }
                };
                if (type === 'text') {
                    newEl.content = content || '新しいテキスト'; // Use provided content or default
                    Object.assign(newEl.style, { width: 'auto', color: '#212529', fontSize: 24, fontFamily: 'sans-serif' });
                } else if (type === 'image') {
                    if (!content) { // Content is now the dataURL, no prompt needed
                        console.error('画像データがありません。');
                        return;
                    }
                    newEl.content = content; // content is the Base64 dataURL
                    newEl.style.height = 30; // Default height, user can resize
                } else if (type === 'video') {
                    const url = content || prompt('動画のURLを入力してください:', 'https://www.w3schools.com/html/mov_bbb.mp4');
                    if (!url) return;
                    newEl.content = { url: url, autoplay: false, loop: false, controls: true };
                    newEl.style.height = 30;
                } else if (type === 'table') {
                    // デフォルト2x2の表
                    newEl.content = {
                        rows: 2,
                        cols: 2,
                        data: [
                            ["セル1", "セル2"],
                            ["セル3", "セル4"]
                        ]
                    };
                    newEl.style.height = 30;
                } else if (type === 'iframe') {
                    const url = prompt('埋め込みたいコンテンツのURLを入力してください:');
                    if (!url) return;
                    newEl.content = { url: url, sandbox: 'allow-scripts allow-same-origin allow-popups' }; // デフォルトのsandbox属性
                    newEl.style.width = 50;
                    newEl.style.height = 50;
                }
                slide.elements.push(newEl);
                this.state.selectedElementIds = [newEl.id];
                this.saveState();
                this.render();
                if (type === 'text') setTimeout(() => this.handleCanvasDblClick({ target: this.elements.slideCanvas.querySelector(`[data-id="${newEl.id}"]`) }), 50);
                this.applyCustomCss();
            },

            createAICheckpoint() {
                this.state.aiCheckpoint = JSON.parse(JSON.stringify(this.state.presentation));
                this.elements.restoreCheckpointBtn.disabled = false;
                console.log("AI Checkpoint created.");
            },

            restoreAICheckpoint() {
                if (this.state.aiCheckpoint) {
                    if (confirm('AIによる変更を元に戻しますか？')) {
                        this.state.presentation = this.state.aiCheckpoint;
                        this.state.aiCheckpoint = null; // チェックポイントをクリア
                        // 状態を復元したあとの再設定
                        this.state.activeSlideId = this.state.presentation.slides.find(s => s.id === this.state.activeSlideId)?.id || this.state.presentation.slides[0]?.id;
                        this.state.selectedElementIds = [];

                        this.render();
                        this.saveState();
                        this.elements.restoreCheckpointBtn.disabled = true;
                        console.log("Restored to AI checkpoint.");
                    }
                } else {
                    alert('復元できるAIの変更履歴がありません。');
                }
            },

            startAutonomousMode() {
                this.state.autonomousMode.isActive = true;
                document.getElementById('chat-input-container').style.display = 'none';
                const messagesDiv = document.getElementById('chat-messages');
                messagesDiv.innerHTML += `<div class="ai-msg">🤖 自律モードを開始しました。</div>`;
                // ここに自律的なスライド作成のロジックを追加（次のステップ）
                alert("自律モードが開始されました（機能は現在開発中です）");
            },

            stopAutonomousMode() {
                this.state.autonomousMode.isActive = false;
                document.getElementById('chat-input-container').style.display = 'flex';
                const messagesDiv = document.getElementById('chat-messages');
                messagesDiv.innerHTML += `<div class="ai-msg">🤖 自律モードを停止しました。</div>`;
                if (this.state.autonomousMode.intervalId) {
                    clearInterval(this.state.autonomousMode.intervalId);
                    this.state.autonomousMode.intervalId = null;
                }
            },
            addChart() {
                // Micromodalでグラフ作成モーダルを表示
                if (typeof MicroModal !== "undefined") {
                    MicroModal.show('chart-modal');
                } else {
                    console.error("MicroModal is undefined.");
                }
            },

            deleteSelectedElements() { if (!confirm(`${this.state.selectedElementIds.length}個の要素を削除しますか？`)) return; const slide = this.getActiveSlide(); if (!slide) return; slide.elements = slide.elements.filter(el => !this.state.selectedElementIds.includes(el.id)); this.state.selectedElementIds = []; this.render(); this.saveState(); },

            alignElements(type) {
                const elementsData = this.getSelectedElementsData(); if (elementsData.length < 2) return;
                const pixelElements = this.getElementsWithPixelRects(elementsData); const bounds = this.calculatePixelBounds(pixelElements); const canvasRect = this.state.slideCanvasRect;
                pixelElements.forEach(el => {
                    let newLeft, newTop;
                    switch (type) {
                        case 'left': newLeft = bounds.minX; break; case 'center-h': newLeft = bounds.centerX - el.rect.width / 2; break;
                        case 'right': newLeft = bounds.maxX - el.rect.width; break; case 'top': newTop = bounds.minY; break;
                        case 'center-v': newTop = bounds.centerY - el.rect.height / 2; break; case 'bottom': newTop = bounds.maxY - el.rect.height; break;
                    }
                    if (newLeft !== undefined) el.data.style.left = newLeft / canvasRect.width * 100;
                    if (newTop !== undefined) el.data.style.top = newTop / canvasRect.height * 100;
                });
                this.render(); this.saveState();
            },

            distributeElements(direction) {
                const elementsData = this.getSelectedElementsData(); if (elementsData.length < 3) return;
                const pixelElements = this.getElementsWithPixelRects(elementsData); const canvasRect = this.state.slideCanvasRect;
                let guidePositions = [];
                if (direction === 'horizontal') {
                    pixelElements.sort((a, b) => a.rect.left - b.rect.left); const bounds = this.calculatePixelBounds(pixelElements);
                    const totalWidth = pixelElements.reduce((sum, el) => sum + el.rect.width, 0); const gap = (bounds.width - totalWidth) / (pixelElements.length - 1);
                    let currentX = bounds.minX;
                    pixelElements.forEach((el, idx) => {
                        el.data.style.left = currentX / canvasRect.width * 100;
                        // ガイド線位置（左端以外）
                        if (idx > 0 && idx < pixelElements.length) {
                            guidePositions.push(currentX);
                        }
                        currentX += el.rect.width + gap;
                    });
                    // 最後のガイド線
                    guidePositions.push(bounds.maxX);
                } else {
                    pixelElements.sort((a, b) => a.rect.top - b.rect.top); const bounds = this.calculatePixelBounds(pixelElements);
                    const totalHeight = pixelElements.reduce((sum, el) => sum + el.rect.height, 0); const gap = (bounds.height - totalHeight) / (pixelElements.length - 1);
                    let currentY = bounds.minY;
                    pixelElements.forEach((el, idx) => {
                        el.data.style.top = currentY / canvasRect.height * 100;
                        if (idx > 0 && idx < pixelElements.length) {
                            guidePositions.push(currentY);
                        }
                        currentY += el.rect.height + gap;
                    });
                    guidePositions.push(bounds.maxY);
                }
                this.render();
                // 等間隔ガイド線の描画
                setTimeout(() => {
                    this.guideLineManager.clear();
                    guidePositions.forEach(pos => {
                        if (direction === 'horizontal') {
                            this.guideLineManager.addGuide('vertical', pos);
                        } else {
                            this.guideLineManager.addGuide('horizontal', pos);
                        }
                    });
                    // ガイド線は2秒後に自動消去
                    setTimeout(() => this.guideLineManager.clear(), 2000);
                }, 50);
                this.saveState(); this.applyCustomCss();
            },

            // --- 範囲選択用 ---
            handleSelectionBoxStart(e) {
                if (e.button !== 0 || e.target.closest('.slide-element')) return;
                const canvas = this.elements.slideCanvas;
                const rect = canvas.getBoundingClientRect();
                const startX = e.clientX - rect.left;
                const startY = e.clientY - rect.top;
                let selectionBox = document.createElement('div');
                selectionBox.className = 'selection-bounding-box';
                Object.assign(selectionBox.style, {
                    left: `${startX}px`, top: `${startY}px`, width: '0px', height: '0px', pointerEvents: 'none'
                });
                canvas.appendChild(selectionBox);

                const onMouseMove = (ev) => {
                    const curX = ev.clientX - rect.left;
                    const curY = ev.clientY - rect.top;
                    const x = Math.min(startX, curX);
                    const y = Math.min(startY, curY);
                    const w = Math.abs(curX - startX);
                    const h = Math.abs(curY - startY);
                    Object.assign(selectionBox.style, {
                        left: `${x}px`, top: `${y}px`, width: `${w}px`, height: `${h}px`
                    });
                };

                const onMouseUp = (ev) => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    const endX = ev.clientX - rect.left;
                    const endY = ev.clientY - rect.top;
                    const x1 = Math.min(startX, endX), x2 = Math.max(startX, endX);
                    const y1 = Math.min(startY, endY), y2 = Math.max(startY, endY);

                    // 範囲内要素を選択
                    const selected = [];
                    this.getActiveSlide().elements.forEach(el => {
                        const domEl = canvas.querySelector(`[data-id="${el.id}"]`);
                        if (!domEl) return;
                        const elRect = domEl.getBoundingClientRect();
                        const cx = elRect.left - rect.left + elRect.width / 2;
                        const cy = elRect.top - rect.top + elRect.height / 2;
                        if (cx >= x1 && cx <= x2 && cy >= y1 && cy <= y2) selected.push(el.id);
                    });
                    this.state.selectedElementIds = selected;
                    selectionBox.remove();
                    this.render();
                };

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            },

            // --- 複数コピー ---
            copySelectedElements() {
                const slide = this.getActiveSlide();
                if (!slide || this.state.selectedElementIds.length === 0) return;
                const newIds = [];
                this.state.selectedElementIds.forEach(id => {
                    const idx = slide.elements.findIndex(el => el.id === id);
                    if (idx === -1) return;
                    const newEl = JSON.parse(JSON.stringify(slide.elements[idx]));
                    newEl.id = this.generateId('el');
                    newEl.style.left += 2;
                    newEl.style.top += 2;
                    newEl.style.zIndex = slide.elements.length + 1;
                    slide.elements.push(newEl);
                    newIds.push(newEl.id);
                });
                this.state.selectedElementIds = newIds;
                this.render();
                this.saveState();
                this.applyCustomCss();
            },

            getElementsWithPixelRects(elementsData) { return elementsData.map(elData => { const domEl = this.elements.slideCanvas.querySelector(`[data-id="${elData.id}"]`); return { data: elData, rect: { left: domEl.offsetLeft, top: domEl.offsetTop, width: domEl.offsetWidth, height: domEl.offsetHeight, } }; }); },
            calculatePixelBounds(pixelElements) { const bounds = pixelElements.reduce((acc, el) => ({ minX: Math.min(acc.minX, el.rect.left), minY: Math.min(acc.minY, el.rect.top), maxX: Math.max(acc.maxX, el.rect.left + el.rect.width), maxY: Math.max(acc.maxY, el.rect.top + el.rect.height), }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity }); bounds.width = bounds.maxX - bounds.minX; bounds.height = bounds.maxY - bounds.minY; bounds.centerX = bounds.minX + bounds.width / 2; bounds.centerY = bounds.minY + bounds.height / 2; return bounds; },
            getSelectedElementsBoundingBox(inPercent = false) { const els = this.getSelectedElementsData(); if (els.length === 0) return null; const pixelEls = this.getElementsWithPixelRects(els); const bounds = this.calculatePixelBounds(pixelEls); if (!inPercent) return bounds; const canvasRect = this.state.slideCanvasRect; return { left: bounds.minX / canvasRect.width * 100, top: bounds.minY / canvasRect.height * 100, width: bounds.width / canvasRect.width * 100, height: bounds.height / canvasRect.height * 100 }; },
            handleThumbnailClick(e) { const thumb = e.target.closest('.slide-thumbnail'); if (thumb) { this.state.activeSlideId = thumb.dataset.id; this.state.selectedElementIds = []; this.render(); } },
            handleInspectorInput(e) {
                // Stop the event from bubbling up, just in case.
                e.stopPropagation();

                // Ignore events from CodeMirror, it has its own handler.
                if (e.target.closest('.cm-editor')) {
                    return;
                }

                const el = this.getSelectedElement();
                if (!el) return;

                const prop = e.target.dataset.prop;
                if (!prop || prop === 'customCss') return;

                let value;
                if (e.target.type === 'checkbox') {
                    value = e.target.checked;
                } else if (e.target.type === 'number') {
                    value = parseFloat(e.target.value);
                } else {
                    value = e.target.value;
                }

                if (el.style.hasOwnProperty(prop)) {
                    el.style[prop] = value;
                }

                // Update the element on the canvas for real-time feedback
                const domEl = this.elements.slideCanvas.querySelector(`[data-id="${el.id}"]`);
                if (domEl) {
                    this.applyStyles(domEl, el.style);
                }

                // Save state with debounce to avoid excessive calls during rapid input
                // We are NOT calling render(), which is the expensive operation that causes focus loss.
                if (this._saveStateTimeout) {
                    clearTimeout(this._saveStateTimeout);
                }
                this._saveStateTimeout = setTimeout(() => {
                    this.saveState();
                    this._saveStateTimeout = null;
                }, 300); // 300msのデバウンス
            },
            generateId: (p) => `${p}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            getActiveSlide() { return this.state.presentation?.slides.find(s => s.id === this.state.activeSlideId); },
            getSelectedElement() { const id = this.state.selectedElementIds[0]; return this.getActiveSlide()?.elements.find(el => el.id === id); },
            getSelectedElementsData() { const slide = this.getActiveSlide(); if (!slide) return []; return slide.elements.filter(el => this.state.selectedElementIds.includes(el.id)); },
            startPresentation() { document.body.classList.add('presentation-mode'); this.elements.presentationView.requestFullscreen().catch(() => { alert('フルスクリーンモードの開始に失敗しました。'); this.stopPresentation(); }); this.renderPresentationSlide(); window.addEventListener('resize', this.renderPresentationSlide.bind(this)); },
            stopPresentation() { document.body.classList.remove('presentation-mode'); if (document.fullscreenElement) document.exitFullscreen(); window.removeEventListener('resize', this.renderPresentationSlide.bind(this)); },
            changeSlide(dir) {
                const { slides } = this.state.presentation;
                const curIdx = slides.findIndex(s => s.id === this.state.activeSlideId);
                let nextIdx = curIdx + dir;
                if (nextIdx >= 0 && nextIdx < slides.length) {
                    this.setActiveSlide(slides[nextIdx].id);
                }
            },
            setActiveSlide(slideId) {
                if (this.state.presentation.slides.some(s => s.id === slideId)) {
                    this.state.activeSlideId = slideId;
                    this.state.selectedElementIds = [];
                    if (document.body.classList.contains('presentation-mode')) {
                        this.renderPresentationSlide();
                    } else {
                        this.render();
                    }
                }
            },
            changePresentationSlide(dir) { this.changeSlide(dir); },
            renderPresentationSlide() { const slide = this.getActiveSlide(); if (!slide) return; const { presentationSlideContainer } = this.elements; const { settings } = this.state.presentation; presentationSlideContainer.innerHTML = ''; const presW = this.elements.presentationView.clientWidth, presH = this.elements.presentationView.clientHeight; const presRatio = presW / presH, slideRatio = settings.width / settings.height; let sW = (presRatio > slideRatio) ? presH * slideRatio : presW; let scale = sW / settings.width; presentationSlideContainer.style.width = `${settings.width}px`; presentationSlideContainer.style.height = `${settings.height}px`; presentationSlideContainer.style.transform = `translate(-50%, -50%) scale(${scale})`; Object.assign(presentationSlideContainer.style, { position: 'absolute', left: '50%', top: '50%' }); slide.elements.forEach(elData => presentationSlideContainer.appendChild(this.createElementDOM(elData))); },
            showExportMenu(e) { const menu = this.elements.exportMenu; menu.innerHTML = `<div style="padding:8px 12px;cursor:pointer;" id="export-png-btn">PNG保存</div><div style="padding:8px 12px;cursor:pointer;" id="export-pdf-btn">PDF保存</div>`; menu.style.display = 'block'; const rect = this.elements.exportBtn.getBoundingClientRect(); menu.style.left = rect.left + 'px'; menu.style.top = (rect.bottom + 5) + 'px'; document.getElementById('export-png-btn').onclick = () => { this.exportCurrentSlideAsImage(); menu.style.display = 'none'; }; document.getElementById('export-pdf-btn').onclick = () => { this.exportCurrentSlideAsPDF(); menu.style.display = 'none'; }; setTimeout(() => document.addEventListener('click', function h(ev) { if (!menu.contains(ev.target) && !App.elements.exportBtn.contains(ev.target)) { menu.style.display = 'none'; document.removeEventListener('click', h); } }, { once: true }), 10); },
            exportCurrentSlideAsImage() { html2canvas(this.elements.slideCanvas, { backgroundColor: "#fff", scale: 2 }).then(c => { const l = document.createElement('a'); l.download = `slide-${this.state.activeSlideId}.png`; l.href = c.toDataURL(); l.click(); }); },
            exportCurrentSlideAsPDF() {
                const node = this.elements.slideCanvas;
                const { settings } = this.state.presentation;
                const pdf = new window.jspdf.jsPDF({
                    orientation: settings.width > settings.height ? 'l' : 'p',
                    unit: 'px',
                    format: [settings.width, settings.height]
                });
                pdf.html(node, {
                    callback: function (pdf) {
                        pdf.save(`slide-${App.state.activeSlideId}.pdf`);
                    },
                    x: 0,
                    y: 0,
                    width: settings.width,
                    windowWidth: node.offsetWidth, // Ensure the HTML is rendered at its actual width
                    html2canvas: {
                        scale: 2, // 元のhtml2canvasのscaleを維持
                        backgroundColor: "#fff", // 元のhtml2canvasのbackgroundColorを維持
                        logging: true, // デバッグ用にログを出力
                        useCORS: true // クロスオリジン画像を許可
                    }
                });
            },
            moveSlide(fromId, toId) { const s = this.state.presentation.slides; const fromIdx = s.findIndex(s => s.id === fromId), toIdx = s.findIndex(s => s.id === toId); if (fromIdx === -1 || toIdx === -1) return; const [moved] = s.splice(fromIdx, 1); s.splice(toIdx, 0, moved); this.render(); this.saveState(); },
            duplicateSlide(slideId) { const s = this.state.presentation.slides; const idx = s.findIndex(s => s.id === slideId); if (idx === -1) return; const newSlide = JSON.parse(JSON.stringify(s[idx])); newSlide.id = this.generateId('slide'); newSlide.elements.forEach(el => el.id = this.generateId('el')); s.splice(idx + 1, 0, newSlide); this.state.activeSlideId = newSlide.id; this.state.selectedElementIds = []; this.render(); this.saveState(); },
            showContextMenu(e, id, content, handlers) { const oldMenu = document.getElementById(id); if (oldMenu) oldMenu.remove(); const menu = document.createElement('div'); menu.id = id; Object.assign(menu.style, { position: 'fixed', zIndex: 99999, left: e.clientX + 'px', top: e.clientY + 'px', background: '#fff', border: '1px solid var(--border-color)', boxShadow: 'var(--shadow-md)', padding: '4px' }); menu.innerHTML = content; document.body.appendChild(menu); Object.entries(handlers).forEach(([btnId, handler]) => document.getElementById(btnId).onclick = () => { handler(); menu.remove(); }); setTimeout(() => document.addEventListener('click', function h(ev) { if (!menu.contains(ev.target)) { menu.remove(); document.removeEventListener('click', h); } }, { once: true }), 10); },
            showSlideContextMenu(e, slideId) { this.showContextMenu(e, 'slide-context-menu', `<div style="padding:8px 12px;cursor:pointer;" id="slide-duplicate-btn">複製</div><div style="padding:8px 12px;cursor:pointer;color:var(--danger-color);" id="slide-delete-btn">削除</div>`, { 'slide-duplicate-btn': () => this.duplicateSlide(slideId), 'slide-delete-btn': () => { this.state.activeSlideId = slideId; this.deleteSlide(); } }); },
            showPasteContextMenu(e) {
                this.showContextMenu(
                    e,
                    'canvas-context-menu',
                    `<div style="padding:8px 12px;cursor:pointer;" id="canvas-paste-btn">ペースト</div>`,
                    {
                        'canvas-paste-btn': () => this.pasteFromClipboard()
                    }
                );
            },
            showElementContextMenu(e, elId) {
                this.showContextMenu(
                    e,
                    'element-context-menu',
                    `<div style="padding:8px 12px;cursor:pointer;" id="el-copy-btn">コピー</div>
                    <div style="padding:8px 12px;cursor:pointer;" id="el-paste-btn">ペースト</div>
                    <div style="padding:8px 12px;cursor:pointer;" id="el-duplicate-btn">複製</div>
                    <div style="padding:8px 12px;cursor:pointer;" id="el-front-btn">最前面へ</div>
                    <div style="padding:8px 12px;cursor:pointer;" id="el-back-btn">一番うしろへ</div>
                    <div style="padding:8px 12px;cursor:pointer;color:var(--danger-color);" id="el-delete-btn">削除</div>`,
                    {
                        'el-copy-btn': () => this.copyToClipboard(elId),
                        'el-paste-btn': () => this.pasteFromClipboard(),
                        'el-duplicate-btn': () => this.duplicateElement(elId),
                        'el-front-btn': () => { this.bringElementToFront(elId); },
                        'el-back-btn': () => { this.sendElementToBack(elId); },
                        'el-delete-btn': () => { this.state.selectedElementIds = [elId]; this.deleteSelectedElements(); }
                    }
                );
            },
            // 複製（現状のコピー機能）
            duplicateElement(elId) {
                const slide = this.getActiveSlide();
                if (!slide) return;
                const idx = slide.elements.findIndex(el => el.id === elId);
                if (idx === -1) return;
                const newEl = JSON.parse(JSON.stringify(slide.elements[idx]));
                newEl.id = this.generateId('el');
                newEl.style.left += 2;
                newEl.style.top += 2;
                newEl.style.zIndex = slide.elements.length + 1;
                slide.elements.push(newEl);
                this.state.selectedElementIds = [newEl.id];
                this.render();
                this.saveState();
                this.applyCustomCss();
            },
            // クリップボードコピー
            copyToClipboard(elId) {
                const slide = this.getActiveSlide();
                if (!slide) return;
                const el = slide.elements.find(el => el.id === elId);
                if (!el) return;
                window._slideClipboard = JSON.parse(JSON.stringify(el));
            },
            // クリップボードペースト
            pasteFromClipboard() {
                const slide = this.getActiveSlide();
                if (!slide || !window._slideClipboard) return;
                const newEl = JSON.parse(JSON.stringify(window._slideClipboard));
                newEl.id = this.generateId('el');
                newEl.style.left += 4;
                newEl.style.top += 4;
                newEl.style.zIndex = slide.elements.length + 1;
                slide.elements.push(newEl);
                this.state.selectedElementIds = [newEl.id];
                this.render();
                this.saveState();
                this.applyCustomCss();
            },

            initCategoryFilters(iconType) {
                let categories;
                let filterContainer;
                let activeElements;

                if (iconType === 'fa') {
                    categories = ['すべて', ...new Set(this.config.fontAwesomeIcons.map(icon => icon.category))];
                    filterContainer = this.elements.faIconCategoryFilter;
                    activeElements = this.elements.faIconSearchInput;
                } else if (iconType === 'mi') {
                    categories = ['すべて', ...new Set(this.config.materialIcons.map(icon => icon.category))];
                    filterContainer = this.elements.miIconCategoryFilter;
                    activeElements = this.elements.miIconSearchInput;
                } else {
                    return; // 未知のアイコンタイプ
                }

                filterContainer.innerHTML = '';

                categories.forEach(category => {
                    const button = document.createElement('button');
                    button.textContent = category;
                    button.dataset.category = category;
                    Object.assign(button.style, {
                        padding: '4px 10px',
                        border: '1px solid var(--border-color)',
                        borderRadius: '12px',
                        background: 'transparent',
                        cursor: 'pointer',
                        fontSize: '12px'
                    });

                    if (category === 'すべて') {
                        button.classList.add('active');
                        button.style.backgroundColor = 'var(--primary-color)';
                        button.style.color = 'white';
                        button.style.borderColor = 'var(--primary-color)';
                    }

                    button.addEventListener('click', () => {
                        filterContainer.querySelectorAll('button').forEach(btn => {
                            btn.classList.remove('active');
                            btn.style.backgroundColor = 'transparent';
                            btn.style.color = 'inherit';
                            btn.style.borderColor = 'var(--border-color)';
                        });
                        button.classList.add('active');
                        button.style.backgroundColor = 'var(--primary-color)';
                        button.style.color = 'white';
                        button.style.borderColor = 'var(--primary-color)';

                        activeElements.value = ''; // カテゴリ変更時に検索をクリア
                        this.renderIconList(iconType, '', category);
                    });
                    filterContainer.appendChild(button);
                });
            },

            renderIconList(iconType, searchTerm = '', category = 'すべて') {
                let icons;
                let iconListContainer;
                let fuseInstance;

                if (iconType === 'fa') {
                    icons = this.config.fontAwesomeIcons;
                    iconListContainer = this.elements.faIconListContainer;
                    fuseInstance = this.faIconFuse;
                } else if (iconType === 'mi') {
                    icons = this.config.materialIcons;
                    iconListContainer = this.elements.miIconListContainer;
                    fuseInstance = this.miIconFuse;
                } else {
                    return;
                }

                if (!iconListContainer) return;
                iconListContainer.innerHTML = '';

                let filteredIcons = icons;
                if (searchTerm) {
                    filteredIcons = fuseInstance.search(searchTerm).map(r => r.item);
                }

                const lowerSearchTerm = searchTerm.toLowerCase();

                filteredIcons = filteredIcons.filter(icon => {
                    const inCategory = category === 'すべて' || icon.category === category;
                    const matchesSearch = !searchTerm ||
                        icon.name.toLowerCase().includes(lowerSearchTerm) ||
                        icon.category.toLowerCase().includes(lowerSearchTerm) ||
                        (icon.class && icon.class.toLowerCase().includes(lowerSearchTerm)) ||
                        (icon.alias && icon.alias.toLowerCase().includes(lowerSearchTerm));
                    return inCategory && matchesSearch;
                });

                filteredIcons.forEach(icon => {
                    const iconDiv = document.createElement('div');
                    iconDiv.className = 'icon-item';
                    iconDiv.dataset.iconClass = icon.class;
                    iconDiv.dataset.iconType = iconType;
                    iconDiv.style.padding = '10px';
                    iconDiv.style.border = '1px solid var(--border-color)';
                    iconDiv.style.borderRadius = 'var(--border-radius)';
                    iconDiv.style.cursor = 'pointer';
                    iconDiv.style.textAlign = 'center';
                    iconDiv.style.minWidth = '60px';

                    if (iconType === 'fa') {
                        let stylePrefix = 'fas';
                        const styleSelect = document.getElementById('fa-style-select');
                        if (styleSelect) stylePrefix = styleSelect.value;
                        const faClass = icon.class.replace(/^(fas|far|fal|fat)\s/, stylePrefix + ' ');
                        const iTag = document.createElement('i');
                        iTag.className = `${faClass} fa-2x`;
                        iTag.style.pointerEvents = 'none';
                        iconDiv.appendChild(iTag);
                    } else if (iconType === 'mi') {
                        let stylePrefix = 'material-icons';
                        const styleSelect = document.getElementById('mi-style-select');
                        if (styleSelect) stylePrefix = styleSelect.value;
                        const spanTag = document.createElement('span');
                        spanTag.className = `${stylePrefix}`;
                        spanTag.textContent = icon.class; // Material Icons uses the class name as text content
                        spanTag.style.fontSize = '2em'; // Adjust size for visibility
                        spanTag.style.pointerEvents = 'none';
                        iconDiv.appendChild(spanTag);
                    }
                    iconListContainer.appendChild(iconDiv);
                });
            },

            addIconElement(iconType, iconClass) {
                const slide = this.getActiveSlide();
                if (!slide) return;

                const newEl = {
                    id: this.generateId('el'),
                    type: 'icon',
                    iconType: iconType, // Store icon type (fa or mi)
                    content: iconClass, // Class string for FA, class name for MI
                    style: {
                        top: 20, left: 20, width: null, height: null,
                        zIndex: slide.elements.length + 1,
                        rotation: 0,
                        color: '#212529',
                        fontSize: 48,
                        animation: ''
                    }
                };

                if (iconType === 'mi') {
                    // For Material Icons, also store the actual icon name (content for span tag)
                    newEl.miContent = iconClass;
                    // Material Iconsのスタイルを適用
                    const miStyleSelect = document.getElementById('mi-style-select');
                    if (miStyleSelect) {
                        newEl.content = miStyleSelect.value; // e.g., "material-icons-outlined"
                    }
                }

                slide.elements.push(newEl);
                this.state.selectedElementIds = [newEl.id];
                this.saveState();
                this.render();
            },
            // Inspectorでアイコンのスタイルを変更する関数
            updateIconStyle(element, newStylePrefix) {
                if (element.iconType === 'fa') {
                    // Font Awesomeの場合、クラス名を更新
                    element.content = element.content.replace(/^(fas|far|fal|fat)\s/, newStylePrefix + ' ');
                } else if (element.iconType === 'mi') {
                    // Material Iconsの場合、クラス名を更新 (miContentはそのまま)
                    element.content = newStylePrefix;
                }
                App.saveState();
                App.render();
            },

            // 要素のzIndexを最大に
            bringElementToFront(elId) {
                const slide = this.getActiveSlide();
                if (!slide) return;
                const maxZ = Math.max(...slide.elements.map(el => el.style.zIndex || 1));
                const el = slide.elements.find(el => el.id === elId);
                if (el) {
                    el.style.zIndex = maxZ + 1;
                    this.saveState();
                    this.render();
                }
            },
            // 要素のzIndexを最小に
            sendElementToBack(elId) {
                const slide = this.getActiveSlide();
                if (!slide) return;
                const minZ = Math.min(...slide.elements.map(el => el.style.zIndex || 1));
                const el = slide.elements.find(el => el.id === elId);
                if (el) {
                    el.style.zIndex = minZ - 1;
                    this.saveState();
                    this.render();
                }
            },

            async initGlobalCssEditor() {
                if (this.cmInstances.globalCssEditor) return;
                const container = document.getElementById('global-css-input');
                if (!container || !window.codemirror) return;
                const cssLang = window.codemirror.langs.css();
                this.cmInstances.globalCssEditor = new window.codemirror.EditorView({
                    doc: this.state.presentation.settings.globalCss || '',
                    extensions: [
                        cssLang,
                        window.codemirror.basicSetup,
                        window.codemirror.lint.linter(window.codemirror.langs.cssLinter),
                        window.codemirror.lint.lintGutter()
                    ],
                    parent: container
                });
            },

            async initElementCssEditor(initialContent) {
                if (this.cmInstances.elementCssEditor) {
                    this.cmInstances.elementCssEditor.destroy();
                }
                const container = document.getElementById('element-css-editor-container');
                if (!container || !window.codemirror) return;
                const cssLang = window.codemirror.langs.css();
                const updateListener = window.codemirror.EditorView.updateListener.of((update) => {
                    if (update.docChanged) {
                        const el = this.getSelectedElement();
                        if (el) {
                            el.style.customCss = update.state.doc.toString();
                            this.applyCustomCss();
                            this.saveState();
                        }
                    }
                });

                this.cmInstances.elementCssEditor = new window.codemirror.EditorView({
                    doc: initialContent,
                    extensions: [
                        cssLang,
                        window.codemirror.basicSetup,
                        updateListener,
                        window.codemirror.lint.linter(window.codemirror.langs.cssLinter),
                        window.codemirror.lint.lintGutter()
                    ],
                    parent: container
                });
            },

            applyCustomCss() {
                const globalCss = this.state.presentation.settings.globalCss || '';
                document.getElementById('global-custom-styles').textContent = globalCss;

                const slide = this.getActiveSlide();
                if (!slide) return;

                let elementCss = '';
                slide.elements.forEach(el => {
                    if (el.style.customCss) {
                        // Add !important to each rule to ensure it overrides inline styles
                        const importantCss = el.style.customCss.split(';')
                            .map(s => s.trim())
                            .filter(s => s)
                            .map(s => s + ' !important')
                            .join('; ');
                        elementCss += `[data-id="${el.id}"] { ${importantCss} }\n`;
                    }
                });
                document.getElementById('elements-custom-styles').textContent = elementCss;
            },
        };

        // スライドリスト上でのスクロールでスライド切り替え
        document.getElementById('bottom-pane').addEventListener('wheel', function (e) {
            const deltaY = e.deltaY;
            if (Math.abs(deltaY) > 30) {
                e.preventDefault();
                if (deltaY > 0) {
                    App.changeSlide(1);
                } else {
                    App.changeSlide(-1);
                }
            }
        }, { passive: false });

        document.addEventListener('DOMContentLoaded', async () => {
            // CodeMirror 6 modules (dynamic import from esm.sh to prevent dependency duplication)
            const { EditorView } = await import('https://esm.sh/@codemirror/view');
            const { basicSetup } = await import('https://esm.sh/codemirror');
            const { css, cssLinter } = await import('https://esm.sh/@codemirror/lang-css');
            const { linter, lintGutter } = await import('https://esm.sh/@codemirror/lint');

            // スライドリスト上でのスクロールでスライド切り替え (App初期化後に登録)
            setTimeout(() => {
                const container = document.getElementById('bottom-pane');
                if (container) {
                    container.addEventListener('wheel', function (e) {
                        const deltaY = e.deltaY;
                        if (Math.abs(deltaY) > 30) {
                            e.preventDefault();
                            if (deltaY > 0) {
                                App.changeSlide(1);
                            } else {
                                App.changeSlide(-1);
                            }
                        }
                    }, { passive: false });
                }
            }, 500);

            window.codemirror = {
                EditorView: EditorView,
                basicSetup: basicSetup,
                langs: {
                    css: css,
                    cssLinter: cssLinter
                },
                lint: {
                    linter: linter,
                    lintGutter: lintGutter
                }
            };

            // カスタムCSS適用用のstyleタグをheadに準備
            const globalStyleTag = document.createElement('style');
            globalStyleTag.id = 'global-custom-styles';
            document.head.appendChild(globalStyleTag);

            const elementStyleTag = document.createElement('style');
            elementStyleTag.id = 'elements-custom-styles';
            document.head.appendChild(elementStyleTag);

            if (typeof MicroModal === 'undefined' && typeof module !== 'undefined' && module.exports) {
                window.MicroModal = module.exports;
            }
            if (typeof MicroModal !== "undefined") {
                MicroModal.init({
                    awaitCloseAnimation: true,
                    disableScroll: true
                });
            }
            await App.loadIconData(); // アイコンデータを先に読み込む
            App.init();
        });
    </script>
</body>

</html>